// File generated by tools/gen_vk.py
// NOLINTBEGIN
#pragma once

#include <stddef.h>
#include <stdint.h>

using xcb_connection_t = struct xcb_connection_t;
using xcb_window_t = uint32_t;
using xcb_visualid_t = uint32_t;

namespace vull::vkb {

#if defined(_WIN32)
#define VKAPI_PTR __stdcall
#else
#define VKAPI_PTR
#endif

constexpr uint32_t k_max_physical_device_name_size = 256;
constexpr uint32_t k_uuid_size = 16;
constexpr uint32_t k_luid_size = 8;
constexpr uint32_t k_max_extension_name_size = 256;
constexpr uint32_t k_max_description_size = 256;
constexpr uint32_t k_max_memory_types = 32;
constexpr uint32_t k_max_memory_heaps = 16;
constexpr float k_lod_clamp_none = 1000.0f;
constexpr uint32_t k_remaining_mip_levels = (~0u);
constexpr uint32_t k_remaining_array_layers = (~0u);
constexpr uint32_t k_remaining_3d_slices_ext = (~0u);
constexpr uint64_t k_whole_size = (~0ull);
constexpr uint32_t k_attachment_unused = (~0u);
constexpr uint32_t k_queue_family_ignored = (~0u);
constexpr uint32_t k_queue_family_external = (~1u);
constexpr uint32_t k_queue_family_foreign_ext = (~2u);
constexpr uint32_t k_subpass_external = (~0u);
constexpr uint32_t k_max_device_group_size = 32;
constexpr uint32_t k_max_driver_name_size = 256;
constexpr uint32_t k_max_driver_info_size = 256;
constexpr uint32_t k_shader_unused_khr = (~0u);
constexpr uint32_t k_max_global_priority_size = 16;
constexpr uint32_t k_max_shader_module_identifier_size_ext = 32;
constexpr uint32_t k_max_pipeline_binary_key_size_khr = 32;
constexpr uint32_t k_max_video_av1_references_per_frame_khr = 7;
constexpr uint32_t k_shader_index_unused_amdx = (~0u);
constexpr uint32_t k_partitioned_acceleration_structure_partition_index_global_nv = (~0u);

// Base types.
using DeviceAddress = uint64_t;
using DeviceSize = uint64_t;
using Flags = uint32_t;
using Flags64 = uint64_t;
using SampleMask = uint32_t;

class Bool {
    uint32_t m_value;

public:
    Bool() = default;
    Bool(bool value) : m_value(value ? 1 : 0) {}
    operator bool() const { return m_value == 1; }
};

// Bitmasks.
using BufferViewCreateFlags = Flags;
using CommandPoolTrimFlags = Flags;
using DebugUtilsMessengerCallbackDataFlagsEXT = Flags;
using DebugUtilsMessengerCreateFlagsEXT = Flags;
using DescriptorPoolResetFlags = Flags;
using DescriptorUpdateTemplateCreateFlags = Flags;
using DeviceCreateFlags = Flags;
using InstanceCreateFlags = Flags;
using MemoryMapFlags = Flags;
using PipelineCacheCreateFlags = Flags;
using PipelineColorBlendStateCreateFlags = Flags;
using PipelineDepthStencilStateCreateFlags = Flags;
using PipelineDynamicStateCreateFlags = Flags;
using PipelineInputAssemblyStateCreateFlags = Flags;
using PipelineLayoutCreateFlags = Flags;
using PipelineMultisampleStateCreateFlags = Flags;
using PipelineRasterizationStateCreateFlags = Flags;
using PipelineTessellationStateCreateFlags = Flags;
using PipelineVertexInputStateCreateFlags = Flags;
using PipelineViewportStateCreateFlags = Flags;
using PrivateDataSlotCreateFlags = Flags;
using QueryPoolCreateFlags = Flags;
using RenderPassCreateFlags = Flags;
using SemaphoreCreateFlags = Flags;
using ShaderModuleCreateFlags = Flags;
using SubpassDescriptionFlags = Flags;
using XcbSurfaceCreateFlagsKHR = Flags;

// Handles.
using Buffer = struct Buffer_T *;
using BufferView = struct BufferView_T *;
using CommandBuffer = struct CommandBuffer_T *;
using CommandPool = struct CommandPool_T *;
using DebugUtilsMessengerEXT = struct DebugUtilsMessengerEXT_T *;
using DescriptorPool = struct DescriptorPool_T *;
using DescriptorSet = struct DescriptorSet_T *;
using DescriptorSetLayout = struct DescriptorSetLayout_T *;
using DescriptorUpdateTemplate = struct DescriptorUpdateTemplate_T *;
using Device = struct Device_T *;
using DeviceMemory = struct DeviceMemory_T *;
using Event = struct Event_T *;
using Fence = struct Fence_T *;
using Framebuffer = struct Framebuffer_T *;
using Image = struct Image_T *;
using ImageView = struct ImageView_T *;
using Instance = struct Instance_T *;
using PhysicalDevice = struct PhysicalDevice_T *;
using Pipeline = struct Pipeline_T *;
using PipelineCache = struct PipelineCache_T *;
using PipelineLayout = struct PipelineLayout_T *;
using PrivateDataSlot = struct PrivateDataSlot_T *;
using QueryPool = struct QueryPool_T *;
using Queue = struct Queue_T *;
using RenderPass = struct RenderPass_T *;
using Sampler = struct Sampler_T *;
using SamplerYcbcrConversion = struct SamplerYcbcrConversion_T *;
using Semaphore = struct Semaphore_T *;
using ShaderModule = struct ShaderModule_T *;
using SurfaceKHR = struct SurfaceKHR_T *;
using SwapchainKHR = struct SwapchainKHR_T *;

// Enums.
enum class Access {
    IndirectCommandRead = 1u << 0u,
    IndexRead = 1u << 1u,
    VertexAttributeRead = 1u << 2u,
    UniformRead = 1u << 3u,
    InputAttachmentRead = 1u << 4u,
    ShaderRead = 1u << 5u,
    ShaderWrite = 1u << 6u,
    ColorAttachmentRead = 1u << 7u,
    ColorAttachmentWrite = 1u << 8u,
    DepthStencilAttachmentRead = 1u << 9u,
    DepthStencilAttachmentWrite = 1u << 10u,
    TransferRead = 1u << 11u,
    TransferWrite = 1u << 12u,
    HostRead = 1u << 13u,
    HostWrite = 1u << 14u,
    MemoryRead = 1u << 15u,
    MemoryWrite = 1u << 16u,
    None = 0,
};
inline constexpr Access operator&(Access lhs, Access rhs) {
    return static_cast<Access>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr Access operator|(Access lhs, Access rhs) {
    return static_cast<Access>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class Access2 : uint64_t {
    None = 0,
    IndirectCommandRead = 1ull << 0ull,
    IndexRead = 1ull << 1ull,
    VertexAttributeRead = 1ull << 2ull,
    UniformRead = 1ull << 3ull,
    InputAttachmentRead = 1ull << 4ull,
    ShaderRead = 1ull << 5ull,
    ShaderWrite = 1ull << 6ull,
    ColorAttachmentRead = 1ull << 7ull,
    ColorAttachmentWrite = 1ull << 8ull,
    DepthStencilAttachmentRead = 1ull << 9ull,
    DepthStencilAttachmentWrite = 1ull << 10ull,
    TransferRead = 1ull << 11ull,
    TransferWrite = 1ull << 12ull,
    HostRead = 1ull << 13ull,
    HostWrite = 1ull << 14ull,
    MemoryRead = 1ull << 15ull,
    MemoryWrite = 1ull << 16ull,
    ShaderSampledRead = 1ull << 32ull,
    ShaderStorageRead = 1ull << 33ull,
    ShaderStorageWrite = 1ull << 34ull,
    DescriptorBufferReadEXT = 1ull << 41ull,
};
inline constexpr Access2 operator&(Access2 lhs, Access2 rhs) {
    return static_cast<Access2>(static_cast<uint64_t>(lhs) & static_cast<uint64_t>(rhs));
}
inline constexpr Access2 operator|(Access2 lhs, Access2 rhs) {
    return static_cast<Access2>(static_cast<uint64_t>(lhs) | static_cast<uint64_t>(rhs));
}

enum class AttachmentDescriptionFlags {
    None = 0,
    MayAlias = 1u << 0u,
};
inline constexpr AttachmentDescriptionFlags operator&(AttachmentDescriptionFlags lhs, AttachmentDescriptionFlags rhs) {
    return static_cast<AttachmentDescriptionFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr AttachmentDescriptionFlags operator|(AttachmentDescriptionFlags lhs, AttachmentDescriptionFlags rhs) {
    return static_cast<AttachmentDescriptionFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class AttachmentLoadOp {
    Load = 0,
    Clear = 1,
    DontCare = 2,
};

enum class AttachmentStoreOp {
    Store = 0,
    DontCare = 1,
    None = 1000301000,
};

enum class BlendFactor {
    Zero = 0,
    One = 1,
    SrcColor = 2,
    OneMinusSrcColor = 3,
    DstColor = 4,
    OneMinusDstColor = 5,
    SrcAlpha = 6,
    OneMinusSrcAlpha = 7,
    DstAlpha = 8,
    OneMinusDstAlpha = 9,
    ConstantColor = 10,
    OneMinusConstantColor = 11,
    ConstantAlpha = 12,
    OneMinusConstantAlpha = 13,
    SrcAlphaSaturate = 14,
    Src1Color = 15,
    OneMinusSrc1Color = 16,
    Src1Alpha = 17,
    OneMinusSrc1Alpha = 18,
};

enum class BlendOp {
    Add = 0,
    Subtract = 1,
    ReverseSubtract = 2,
    Min = 3,
    Max = 4,
};

enum class BorderColor {
    FloatTransparentBlack = 0,
    IntTransparentBlack = 1,
    FloatOpaqueBlack = 2,
    IntOpaqueBlack = 3,
    FloatOpaqueWhite = 4,
    IntOpaqueWhite = 5,
};

enum class BufferCreateFlags {
    None = 0,
    SparseBinding = 1u << 0u,
    SparseResidency = 1u << 1u,
    SparseAliased = 1u << 2u,
    Protected = 1u << 3u,
    DeviceAddressCaptureReplay = 1u << 4u,
    DescriptorBufferCaptureReplayEXT = 1u << 5u,
};
inline constexpr BufferCreateFlags operator&(BufferCreateFlags lhs, BufferCreateFlags rhs) {
    return static_cast<BufferCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr BufferCreateFlags operator|(BufferCreateFlags lhs, BufferCreateFlags rhs) {
    return static_cast<BufferCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class BufferUsage {
    TransferSrc = 1u << 0u,
    TransferDst = 1u << 1u,
    UniformTexelBuffer = 1u << 2u,
    StorageTexelBuffer = 1u << 3u,
    UniformBuffer = 1u << 4u,
    StorageBuffer = 1u << 5u,
    IndexBuffer = 1u << 6u,
    VertexBuffer = 1u << 7u,
    IndirectBuffer = 1u << 8u,
    ShaderDeviceAddress = 1u << 17u,
    SamplerDescriptorBufferEXT = 1u << 21u,
    ResourceDescriptorBufferEXT = 1u << 22u,
    PushDescriptorsDescriptorBufferEXT = 1u << 26u,
};
inline constexpr BufferUsage operator&(BufferUsage lhs, BufferUsage rhs) {
    return static_cast<BufferUsage>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr BufferUsage operator|(BufferUsage lhs, BufferUsage rhs) {
    return static_cast<BufferUsage>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ChromaLocation {
    CositedEven = 0,
    Midpoint = 1,
};

enum class ColorComponent {
    R = 1u << 0u,
    G = 1u << 1u,
    B = 1u << 2u,
    A = 1u << 3u,
};
inline constexpr ColorComponent operator&(ColorComponent lhs, ColorComponent rhs) {
    return static_cast<ColorComponent>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ColorComponent operator|(ColorComponent lhs, ColorComponent rhs) {
    return static_cast<ColorComponent>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ColorSpaceKHR {
    SrgbNonlinear = 0,
};

enum class CommandBufferLevel {
    Primary = 0,
    Secondary = 1,
};

enum class CommandBufferResetFlags {
    None = 0,
    ReleaseResources = 1u << 0u,
};
inline constexpr CommandBufferResetFlags operator&(CommandBufferResetFlags lhs, CommandBufferResetFlags rhs) {
    return static_cast<CommandBufferResetFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr CommandBufferResetFlags operator|(CommandBufferResetFlags lhs, CommandBufferResetFlags rhs) {
    return static_cast<CommandBufferResetFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class CommandBufferUsage {
    OneTimeSubmit = 1u << 0u,
    RenderPassContinue = 1u << 1u,
    SimultaneousUse = 1u << 2u,
};
inline constexpr CommandBufferUsage operator&(CommandBufferUsage lhs, CommandBufferUsage rhs) {
    return static_cast<CommandBufferUsage>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr CommandBufferUsage operator|(CommandBufferUsage lhs, CommandBufferUsage rhs) {
    return static_cast<CommandBufferUsage>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class CommandPoolCreateFlags {
    None = 0,
    Transient = 1u << 0u,
    ResetCommandBuffer = 1u << 1u,
    Protected = 1u << 2u,
};
inline constexpr CommandPoolCreateFlags operator&(CommandPoolCreateFlags lhs, CommandPoolCreateFlags rhs) {
    return static_cast<CommandPoolCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr CommandPoolCreateFlags operator|(CommandPoolCreateFlags lhs, CommandPoolCreateFlags rhs) {
    return static_cast<CommandPoolCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class CommandPoolResetFlags {
    None = 0,
    ReleaseResources = 1u << 0u,
};
inline constexpr CommandPoolResetFlags operator&(CommandPoolResetFlags lhs, CommandPoolResetFlags rhs) {
    return static_cast<CommandPoolResetFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr CommandPoolResetFlags operator|(CommandPoolResetFlags lhs, CommandPoolResetFlags rhs) {
    return static_cast<CommandPoolResetFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class CompareOp {
    Never = 0,
    Less = 1,
    Equal = 2,
    LessOrEqual = 3,
    Greater = 4,
    NotEqual = 5,
    GreaterOrEqual = 6,
    Always = 7,
};

enum class ComponentSwizzle {
    Identity = 0,
    Zero = 1,
    One = 2,
    R = 3,
    G = 4,
    B = 5,
    A = 6,
};

enum class CompositeAlphaFlagsKHR {
    Opaque = 1u << 0u,
    PreMultiplied = 1u << 1u,
    PostMultiplied = 1u << 2u,
    Inherit = 1u << 3u,
};
inline constexpr CompositeAlphaFlagsKHR operator&(CompositeAlphaFlagsKHR lhs, CompositeAlphaFlagsKHR rhs) {
    return static_cast<CompositeAlphaFlagsKHR>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr CompositeAlphaFlagsKHR operator|(CompositeAlphaFlagsKHR lhs, CompositeAlphaFlagsKHR rhs) {
    return static_cast<CompositeAlphaFlagsKHR>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class CullMode {
    None = 0,
    Front = 1u << 0u,
    Back = 1u << 1u,
    FrontAndBack = 0x00000003,
};
inline constexpr CullMode operator&(CullMode lhs, CullMode rhs) {
    return static_cast<CullMode>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr CullMode operator|(CullMode lhs, CullMode rhs) {
    return static_cast<CullMode>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DebugUtilsMessageSeverityFlagsEXT {
    Verbose = 1u << 0u,
    Info = 1u << 4u,
    Warning = 1u << 8u,
    Error = 1u << 12u,
};
inline constexpr DebugUtilsMessageSeverityFlagsEXT operator&(DebugUtilsMessageSeverityFlagsEXT lhs, DebugUtilsMessageSeverityFlagsEXT rhs) {
    return static_cast<DebugUtilsMessageSeverityFlagsEXT>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DebugUtilsMessageSeverityFlagsEXT operator|(DebugUtilsMessageSeverityFlagsEXT lhs, DebugUtilsMessageSeverityFlagsEXT rhs) {
    return static_cast<DebugUtilsMessageSeverityFlagsEXT>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DebugUtilsMessageTypeFlagsEXT {
    General = 1u << 0u,
    Validation = 1u << 1u,
    Performance = 1u << 2u,
};
inline constexpr DebugUtilsMessageTypeFlagsEXT operator&(DebugUtilsMessageTypeFlagsEXT lhs, DebugUtilsMessageTypeFlagsEXT rhs) {
    return static_cast<DebugUtilsMessageTypeFlagsEXT>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DebugUtilsMessageTypeFlagsEXT operator|(DebugUtilsMessageTypeFlagsEXT lhs, DebugUtilsMessageTypeFlagsEXT rhs) {
    return static_cast<DebugUtilsMessageTypeFlagsEXT>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DependencyFlags {
    None = 0,
    ByRegion = 1u << 0u,
    DeviceGroup = 1u << 2u,
    ViewLocal = 1u << 1u,
};
inline constexpr DependencyFlags operator&(DependencyFlags lhs, DependencyFlags rhs) {
    return static_cast<DependencyFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DependencyFlags operator|(DependencyFlags lhs, DependencyFlags rhs) {
    return static_cast<DependencyFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DescriptorBindingFlags {
    None = 0,
    UpdateAfterBind = 1u << 0u,
    UpdateUnusedWhilePending = 1u << 1u,
    PartiallyBound = 1u << 2u,
    VariableDescriptorCount = 1u << 3u,
};
inline constexpr DescriptorBindingFlags operator&(DescriptorBindingFlags lhs, DescriptorBindingFlags rhs) {
    return static_cast<DescriptorBindingFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DescriptorBindingFlags operator|(DescriptorBindingFlags lhs, DescriptorBindingFlags rhs) {
    return static_cast<DescriptorBindingFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DescriptorPoolCreateFlags {
    None = 0,
    FreeDescriptorSet = 1u << 0u,
    UpdateAfterBind = 1u << 1u,
};
inline constexpr DescriptorPoolCreateFlags operator&(DescriptorPoolCreateFlags lhs, DescriptorPoolCreateFlags rhs) {
    return static_cast<DescriptorPoolCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DescriptorPoolCreateFlags operator|(DescriptorPoolCreateFlags lhs, DescriptorPoolCreateFlags rhs) {
    return static_cast<DescriptorPoolCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DescriptorSetLayoutCreateFlags {
    None = 0,
    UpdateAfterBindPool = 1u << 1u,
    DescriptorBufferEXT = 1u << 4u,
    EmbeddedImmutableSamplersEXT = 1u << 5u,
};
inline constexpr DescriptorSetLayoutCreateFlags operator&(DescriptorSetLayoutCreateFlags lhs, DescriptorSetLayoutCreateFlags rhs) {
    return static_cast<DescriptorSetLayoutCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DescriptorSetLayoutCreateFlags operator|(DescriptorSetLayoutCreateFlags lhs, DescriptorSetLayoutCreateFlags rhs) {
    return static_cast<DescriptorSetLayoutCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DescriptorType {
    Sampler = 0,
    CombinedImageSampler = 1,
    SampledImage = 2,
    StorageImage = 3,
    UniformTexelBuffer = 4,
    StorageTexelBuffer = 5,
    UniformBuffer = 6,
    StorageBuffer = 7,
    UniformBufferDynamic = 8,
    StorageBufferDynamic = 9,
    InputAttachment = 10,
    InlineUniformBlock = 1000138000,
};

enum class DescriptorUpdateTemplateType {
    DescriptorSet = 0,
};

enum class DeviceGroupPresentModeKHR {
    Local = 1u << 0u,
    Remote = 1u << 1u,
    Sum = 1u << 2u,
    LocalMultiDevice = 1u << 3u,
};
inline constexpr DeviceGroupPresentModeKHR operator&(DeviceGroupPresentModeKHR lhs, DeviceGroupPresentModeKHR rhs) {
    return static_cast<DeviceGroupPresentModeKHR>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DeviceGroupPresentModeKHR operator|(DeviceGroupPresentModeKHR lhs, DeviceGroupPresentModeKHR rhs) {
    return static_cast<DeviceGroupPresentModeKHR>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DeviceQueueCreateFlags {
    None = 0,
    Protected = 1u << 0u,
};
inline constexpr DeviceQueueCreateFlags operator&(DeviceQueueCreateFlags lhs, DeviceQueueCreateFlags rhs) {
    return static_cast<DeviceQueueCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr DeviceQueueCreateFlags operator|(DeviceQueueCreateFlags lhs, DeviceQueueCreateFlags rhs) {
    return static_cast<DeviceQueueCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class DriverId {
    AmdProprietary = 1,
    AmdOpenSource = 2,
    MesaRadv = 3,
    NvidiaProprietary = 4,
    IntelProprietaryWindows = 5,
    IntelOpenSourceMESA = 6,
    ImaginationProprietary = 7,
    QualcommProprietary = 8,
    ArmProprietary = 9,
    GoogleSwiftshader = 10,
    GgpProprietary = 11,
    BroadcomProprietary = 12,
    MesaLlvmpipe = 13,
    Moltenvk = 14,
    CoreaviProprietary = 15,
    JuiceProprietary = 16,
    VerisiliconProprietary = 17,
    MesaTurnip = 18,
    MesaV3Dv = 19,
    MesaPanvk = 20,
    SamsungProprietary = 21,
    MesaVenus = 22,
    MesaDozen = 23,
    MesaNvk = 24,
    ImaginationOpenSourceMESA = 25,
    MesaHoneykrisp = 26,
    VulkanScEmulationOnVulkan = 27,
};

enum class DynamicState {
    Viewport = 0,
    Scissor = 1,
    LineWidth = 2,
    DepthBias = 3,
    BlendConstants = 4,
    DepthBounds = 5,
    StencilCompareMask = 6,
    StencilWriteMask = 7,
    StencilReference = 8,
    CullMode = 1000267000,
    FrontFace = 1000267001,
    PrimitiveTopology = 1000267002,
    ViewportWithCount = 1000267003,
    ScissorWithCount = 1000267004,
    VertexInputBindingStride = 1000267005,
    DepthTestEnable = 1000267006,
    DepthWriteEnable = 1000267007,
    DepthCompareOp = 1000267008,
    DepthBoundsTestEnable = 1000267009,
    StencilTestEnable = 1000267010,
    StencilOp = 1000267011,
    RasterizerDiscardEnable = 1000377001,
    DepthBiasEnable = 1000377002,
    PrimitiveRestartEnable = 1000377004,
};

enum class EventCreateFlags {
    None = 0,
    DeviceOnly = 1u << 0u,
};
inline constexpr EventCreateFlags operator&(EventCreateFlags lhs, EventCreateFlags rhs) {
    return static_cast<EventCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr EventCreateFlags operator|(EventCreateFlags lhs, EventCreateFlags rhs) {
    return static_cast<EventCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ExternalFenceFeature {
    Exportable = 1u << 0u,
    Importable = 1u << 1u,
};
inline constexpr ExternalFenceFeature operator&(ExternalFenceFeature lhs, ExternalFenceFeature rhs) {
    return static_cast<ExternalFenceFeature>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ExternalFenceFeature operator|(ExternalFenceFeature lhs, ExternalFenceFeature rhs) {
    return static_cast<ExternalFenceFeature>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ExternalFenceHandleTypeFlags {
    None = 0,
    OpaqueFd = 1u << 0u,
    OpaqueWin32 = 1u << 1u,
    OpaqueWin32Kmt = 1u << 2u,
    SyncFd = 1u << 3u,
};
inline constexpr ExternalFenceHandleTypeFlags operator&(ExternalFenceHandleTypeFlags lhs, ExternalFenceHandleTypeFlags rhs) {
    return static_cast<ExternalFenceHandleTypeFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ExternalFenceHandleTypeFlags operator|(ExternalFenceHandleTypeFlags lhs, ExternalFenceHandleTypeFlags rhs) {
    return static_cast<ExternalFenceHandleTypeFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ExternalMemoryFeature {
    DedicatedOnly = 1u << 0u,
    Exportable = 1u << 1u,
    Importable = 1u << 2u,
};
inline constexpr ExternalMemoryFeature operator&(ExternalMemoryFeature lhs, ExternalMemoryFeature rhs) {
    return static_cast<ExternalMemoryFeature>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ExternalMemoryFeature operator|(ExternalMemoryFeature lhs, ExternalMemoryFeature rhs) {
    return static_cast<ExternalMemoryFeature>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ExternalMemoryHandleTypeFlags {
    None = 0,
    OpaqueFd = 1u << 0u,
    OpaqueWin32 = 1u << 1u,
    OpaqueWin32Kmt = 1u << 2u,
    D3D11Texture = 1u << 3u,
    D3D11TextureKmt = 1u << 4u,
    D3D12Heap = 1u << 5u,
    D3D12Resource = 1u << 6u,
};
inline constexpr ExternalMemoryHandleTypeFlags operator&(ExternalMemoryHandleTypeFlags lhs, ExternalMemoryHandleTypeFlags rhs) {
    return static_cast<ExternalMemoryHandleTypeFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ExternalMemoryHandleTypeFlags operator|(ExternalMemoryHandleTypeFlags lhs, ExternalMemoryHandleTypeFlags rhs) {
    return static_cast<ExternalMemoryHandleTypeFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ExternalSemaphoreFeature {
    Exportable = 1u << 0u,
    Importable = 1u << 1u,
};
inline constexpr ExternalSemaphoreFeature operator&(ExternalSemaphoreFeature lhs, ExternalSemaphoreFeature rhs) {
    return static_cast<ExternalSemaphoreFeature>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ExternalSemaphoreFeature operator|(ExternalSemaphoreFeature lhs, ExternalSemaphoreFeature rhs) {
    return static_cast<ExternalSemaphoreFeature>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ExternalSemaphoreHandleTypeFlags {
    None = 0,
    OpaqueFd = 1u << 0u,
    OpaqueWin32 = 1u << 1u,
    OpaqueWin32Kmt = 1u << 2u,
    D3D12Fence = 1u << 3u,
    SyncFd = 1u << 4u,
};
inline constexpr ExternalSemaphoreHandleTypeFlags operator&(ExternalSemaphoreHandleTypeFlags lhs, ExternalSemaphoreHandleTypeFlags rhs) {
    return static_cast<ExternalSemaphoreHandleTypeFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ExternalSemaphoreHandleTypeFlags operator|(ExternalSemaphoreHandleTypeFlags lhs, ExternalSemaphoreHandleTypeFlags rhs) {
    return static_cast<ExternalSemaphoreHandleTypeFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class FenceCreateFlags {
    None = 0,
    Signaled = 1u << 0u,
};
inline constexpr FenceCreateFlags operator&(FenceCreateFlags lhs, FenceCreateFlags rhs) {
    return static_cast<FenceCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr FenceCreateFlags operator|(FenceCreateFlags lhs, FenceCreateFlags rhs) {
    return static_cast<FenceCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class FenceImportFlags {
    None = 0,
    Temporary = 1u << 0u,
};
inline constexpr FenceImportFlags operator&(FenceImportFlags lhs, FenceImportFlags rhs) {
    return static_cast<FenceImportFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr FenceImportFlags operator|(FenceImportFlags lhs, FenceImportFlags rhs) {
    return static_cast<FenceImportFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class Filter {
    Nearest = 0,
    Linear = 1,
};

enum class Format {
    Undefined = 0,
    R4G4UnormPack8 = 1,
    R4G4B4A4UnormPack16 = 2,
    B4G4R4A4UnormPack16 = 3,
    R5G6B5UnormPack16 = 4,
    B5G6R5UnormPack16 = 5,
    R5G5B5A1UnormPack16 = 6,
    B5G5R5A1UnormPack16 = 7,
    A1R5G5B5UnormPack16 = 8,
    R8Unorm = 9,
    R8Snorm = 10,
    R8Uscaled = 11,
    R8Sscaled = 12,
    R8Uint = 13,
    R8Sint = 14,
    R8Srgb = 15,
    R8G8Unorm = 16,
    R8G8Snorm = 17,
    R8G8Uscaled = 18,
    R8G8Sscaled = 19,
    R8G8Uint = 20,
    R8G8Sint = 21,
    R8G8Srgb = 22,
    R8G8B8Unorm = 23,
    R8G8B8Snorm = 24,
    R8G8B8Uscaled = 25,
    R8G8B8Sscaled = 26,
    R8G8B8Uint = 27,
    R8G8B8Sint = 28,
    R8G8B8Srgb = 29,
    B8G8R8Unorm = 30,
    B8G8R8Snorm = 31,
    B8G8R8Uscaled = 32,
    B8G8R8Sscaled = 33,
    B8G8R8Uint = 34,
    B8G8R8Sint = 35,
    B8G8R8Srgb = 36,
    R8G8B8A8Unorm = 37,
    R8G8B8A8Snorm = 38,
    R8G8B8A8Uscaled = 39,
    R8G8B8A8Sscaled = 40,
    R8G8B8A8Uint = 41,
    R8G8B8A8Sint = 42,
    R8G8B8A8Srgb = 43,
    B8G8R8A8Unorm = 44,
    B8G8R8A8Snorm = 45,
    B8G8R8A8Uscaled = 46,
    B8G8R8A8Sscaled = 47,
    B8G8R8A8Uint = 48,
    B8G8R8A8Sint = 49,
    B8G8R8A8Srgb = 50,
    A8B8G8R8UnormPack32 = 51,
    A8B8G8R8SnormPack32 = 52,
    A8B8G8R8UscaledPack32 = 53,
    A8B8G8R8SscaledPack32 = 54,
    A8B8G8R8UintPack32 = 55,
    A8B8G8R8SintPack32 = 56,
    A8B8G8R8SrgbPack32 = 57,
    A2R10G10B10UnormPack32 = 58,
    A2R10G10B10SnormPack32 = 59,
    A2R10G10B10UscaledPack32 = 60,
    A2R10G10B10SscaledPack32 = 61,
    A2R10G10B10UintPack32 = 62,
    A2R10G10B10SintPack32 = 63,
    A2B10G10R10UnormPack32 = 64,
    A2B10G10R10SnormPack32 = 65,
    A2B10G10R10UscaledPack32 = 66,
    A2B10G10R10SscaledPack32 = 67,
    A2B10G10R10UintPack32 = 68,
    A2B10G10R10SintPack32 = 69,
    R16Unorm = 70,
    R16Snorm = 71,
    R16Uscaled = 72,
    R16Sscaled = 73,
    R16Uint = 74,
    R16Sint = 75,
    R16Sfloat = 76,
    R16G16Unorm = 77,
    R16G16Snorm = 78,
    R16G16Uscaled = 79,
    R16G16Sscaled = 80,
    R16G16Uint = 81,
    R16G16Sint = 82,
    R16G16Sfloat = 83,
    R16G16B16Unorm = 84,
    R16G16B16Snorm = 85,
    R16G16B16Uscaled = 86,
    R16G16B16Sscaled = 87,
    R16G16B16Uint = 88,
    R16G16B16Sint = 89,
    R16G16B16Sfloat = 90,
    R16G16B16A16Unorm = 91,
    R16G16B16A16Snorm = 92,
    R16G16B16A16Uscaled = 93,
    R16G16B16A16Sscaled = 94,
    R16G16B16A16Uint = 95,
    R16G16B16A16Sint = 96,
    R16G16B16A16Sfloat = 97,
    R32Uint = 98,
    R32Sint = 99,
    R32Sfloat = 100,
    R32G32Uint = 101,
    R32G32Sint = 102,
    R32G32Sfloat = 103,
    R32G32B32Uint = 104,
    R32G32B32Sint = 105,
    R32G32B32Sfloat = 106,
    R32G32B32A32Uint = 107,
    R32G32B32A32Sint = 108,
    R32G32B32A32Sfloat = 109,
    R64Uint = 110,
    R64Sint = 111,
    R64Sfloat = 112,
    R64G64Uint = 113,
    R64G64Sint = 114,
    R64G64Sfloat = 115,
    R64G64B64Uint = 116,
    R64G64B64Sint = 117,
    R64G64B64Sfloat = 118,
    R64G64B64A64Uint = 119,
    R64G64B64A64Sint = 120,
    R64G64B64A64Sfloat = 121,
    B10G11R11UfloatPack32 = 122,
    E5B9G9R9UfloatPack32 = 123,
    D16Unorm = 124,
    X8D24UnormPack32 = 125,
    D32Sfloat = 126,
    S8Uint = 127,
    D16UnormS8Uint = 128,
    D24UnormS8Uint = 129,
    D32SfloatS8Uint = 130,
    Bc1RgbUnormBlock = 131,
    Bc1RgbSrgbBlock = 132,
    Bc1RgbaUnormBlock = 133,
    Bc1RgbaSrgbBlock = 134,
    Bc2UnormBlock = 135,
    Bc2SrgbBlock = 136,
    Bc3UnormBlock = 137,
    Bc3SrgbBlock = 138,
    Bc4UnormBlock = 139,
    Bc4SnormBlock = 140,
    Bc5UnormBlock = 141,
    Bc5SnormBlock = 142,
    Bc6HUfloatBlock = 143,
    Bc6HSfloatBlock = 144,
    Bc7UnormBlock = 145,
    Bc7SrgbBlock = 146,
    Etc2R8G8B8UnormBlock = 147,
    Etc2R8G8B8SrgbBlock = 148,
    Etc2R8G8B8A1UnormBlock = 149,
    Etc2R8G8B8A1SrgbBlock = 150,
    Etc2R8G8B8A8UnormBlock = 151,
    Etc2R8G8B8A8SrgbBlock = 152,
    EacR11UnormBlock = 153,
    EacR11SnormBlock = 154,
    EacR11G11UnormBlock = 155,
    EacR11G11SnormBlock = 156,
    Astc4X4UnormBlock = 157,
    Astc4X4SrgbBlock = 158,
    Astc5X4UnormBlock = 159,
    Astc5X4SrgbBlock = 160,
    Astc5X5UnormBlock = 161,
    Astc5X5SrgbBlock = 162,
    Astc6X5UnormBlock = 163,
    Astc6X5SrgbBlock = 164,
    Astc6X6UnormBlock = 165,
    Astc6X6SrgbBlock = 166,
    Astc8X5UnormBlock = 167,
    Astc8X5SrgbBlock = 168,
    Astc8X6UnormBlock = 169,
    Astc8X6SrgbBlock = 170,
    Astc8X8UnormBlock = 171,
    Astc8X8SrgbBlock = 172,
    Astc10X5UnormBlock = 173,
    Astc10X5SrgbBlock = 174,
    Astc10X6UnormBlock = 175,
    Astc10X6SrgbBlock = 176,
    Astc10X8UnormBlock = 177,
    Astc10X8SrgbBlock = 178,
    Astc10X10UnormBlock = 179,
    Astc10X10SrgbBlock = 180,
    Astc12X10UnormBlock = 181,
    Astc12X10SrgbBlock = 182,
    Astc12X12UnormBlock = 183,
    Astc12X12SrgbBlock = 184,
    G8B8G8R8422Unorm = 1000156000,
    B8G8R8G8422Unorm = 1000156001,
    G8B8R83Plane420Unorm = 1000156002,
    G8B8R82Plane420Unorm = 1000156003,
    G8B8R83Plane422Unorm = 1000156004,
    G8B8R82Plane422Unorm = 1000156005,
    G8B8R83Plane444Unorm = 1000156006,
    R10X6UnormPack16 = 1000156007,
    R10X6G10X6Unorm2Pack16 = 1000156008,
    R10X6G10X6B10X6A10X6Unorm4Pack16 = 1000156009,
    G10X6B10X6G10X6R10X6422Unorm4Pack16 = 1000156010,
    B10X6G10X6R10X6G10X6422Unorm4Pack16 = 1000156011,
    G10X6B10X6R10X63Plane420Unorm3Pack16 = 1000156012,
    G10X6B10X6R10X62Plane420Unorm3Pack16 = 1000156013,
    G10X6B10X6R10X63Plane422Unorm3Pack16 = 1000156014,
    G10X6B10X6R10X62Plane422Unorm3Pack16 = 1000156015,
    G10X6B10X6R10X63Plane444Unorm3Pack16 = 1000156016,
    R12X4UnormPack16 = 1000156017,
    R12X4G12X4Unorm2Pack16 = 1000156018,
    R12X4G12X4B12X4A12X4Unorm4Pack16 = 1000156019,
    G12X4B12X4G12X4R12X4422Unorm4Pack16 = 1000156020,
    B12X4G12X4R12X4G12X4422Unorm4Pack16 = 1000156021,
    G12X4B12X4R12X43Plane420Unorm3Pack16 = 1000156022,
    G12X4B12X4R12X42Plane420Unorm3Pack16 = 1000156023,
    G12X4B12X4R12X43Plane422Unorm3Pack16 = 1000156024,
    G12X4B12X4R12X42Plane422Unorm3Pack16 = 1000156025,
    G12X4B12X4R12X43Plane444Unorm3Pack16 = 1000156026,
    G16B16G16R16422Unorm = 1000156027,
    B16G16R16G16422Unorm = 1000156028,
    G16B16R163Plane420Unorm = 1000156029,
    G16B16R162Plane420Unorm = 1000156030,
    G16B16R163Plane422Unorm = 1000156031,
    G16B16R162Plane422Unorm = 1000156032,
    G16B16R163Plane444Unorm = 1000156033,
    G8B8R82Plane444Unorm = 1000330000,
    G10X6B10X6R10X62Plane444Unorm3Pack16 = 1000330001,
    G12X4B12X4R12X42Plane444Unorm3Pack16 = 1000330002,
    G16B16R162Plane444Unorm = 1000330003,
    A4R4G4B4UnormPack16 = 1000340000,
    A4B4G4R4UnormPack16 = 1000340001,
    Astc4X4SfloatBlock = 1000066000,
    Astc5X4SfloatBlock = 1000066001,
    Astc5X5SfloatBlock = 1000066002,
    Astc6X5SfloatBlock = 1000066003,
    Astc6X6SfloatBlock = 1000066004,
    Astc8X5SfloatBlock = 1000066005,
    Astc8X6SfloatBlock = 1000066006,
    Astc8X8SfloatBlock = 1000066007,
    Astc10X5SfloatBlock = 1000066008,
    Astc10X6SfloatBlock = 1000066009,
    Astc10X8SfloatBlock = 1000066010,
    Astc10X10SfloatBlock = 1000066011,
    Astc12X10SfloatBlock = 1000066012,
    Astc12X12SfloatBlock = 1000066013,
};

enum class FormatFeature {
    SampledImage = 1u << 0u,
    StorageImage = 1u << 1u,
    StorageImageAtomic = 1u << 2u,
    UniformTexelBuffer = 1u << 3u,
    StorageTexelBuffer = 1u << 4u,
    StorageTexelBufferAtomic = 1u << 5u,
    VertexBuffer = 1u << 6u,
    ColorAttachment = 1u << 7u,
    ColorAttachmentBlend = 1u << 8u,
    DepthStencilAttachment = 1u << 9u,
    BlitSrc = 1u << 10u,
    BlitDst = 1u << 11u,
    SampledImageFilterLinear = 1u << 12u,
    TransferSrc = 1u << 14u,
    TransferDst = 1u << 15u,
    MidpointChromaSamples = 1u << 17u,
    SampledImageYcbcrConversionLinearFilter = 1u << 18u,
    SampledImageYcbcrConversionSeparateReconstructionFilter = 1u << 19u,
    SampledImageYcbcrConversionChromaReconstructionExplicit = 1u << 20u,
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 1u << 21u,
    Disjoint = 1u << 22u,
    CositedChromaSamples = 1u << 23u,
    SampledImageFilterMinmax = 1u << 16u,
};
inline constexpr FormatFeature operator&(FormatFeature lhs, FormatFeature rhs) {
    return static_cast<FormatFeature>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr FormatFeature operator|(FormatFeature lhs, FormatFeature rhs) {
    return static_cast<FormatFeature>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class FormatFeature2 : uint64_t {
    SampledImage = 1ull << 0ull,
    StorageImage = 1ull << 1ull,
    StorageImageAtomic = 1ull << 2ull,
    UniformTexelBuffer = 1ull << 3ull,
    StorageTexelBuffer = 1ull << 4ull,
    StorageTexelBufferAtomic = 1ull << 5ull,
    VertexBuffer = 1ull << 6ull,
    ColorAttachment = 1ull << 7ull,
    ColorAttachmentBlend = 1ull << 8ull,
    DepthStencilAttachment = 1ull << 9ull,
    BlitSrc = 1ull << 10ull,
    BlitDst = 1ull << 11ull,
    SampledImageFilterLinear = 1ull << 12ull,
    TransferSrc = 1ull << 14ull,
    TransferDst = 1ull << 15ull,
    SampledImageFilterMinmax = 1ull << 16ull,
    MidpointChromaSamples = 1ull << 17ull,
    SampledImageYcbcrConversionLinearFilter = 1ull << 18ull,
    SampledImageYcbcrConversionSeparateReconstructionFilter = 1ull << 19ull,
    SampledImageYcbcrConversionChromaReconstructionExplicit = 1ull << 20ull,
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable = 1ull << 21ull,
    Disjoint = 1ull << 22ull,
    CositedChromaSamples = 1ull << 23ull,
    StorageReadWithoutFormat = 1ull << 31ull,
    StorageWriteWithoutFormat = 1ull << 32ull,
    SampledImageDepthComparison = 1ull << 33ull,
    SampledImageFilterCubic = 1ull << 13ull,
};
inline constexpr FormatFeature2 operator&(FormatFeature2 lhs, FormatFeature2 rhs) {
    return static_cast<FormatFeature2>(static_cast<uint64_t>(lhs) & static_cast<uint64_t>(rhs));
}
inline constexpr FormatFeature2 operator|(FormatFeature2 lhs, FormatFeature2 rhs) {
    return static_cast<FormatFeature2>(static_cast<uint64_t>(lhs) | static_cast<uint64_t>(rhs));
}

enum class FramebufferCreateFlags {
    None = 0,
    Imageless = 1u << 0u,
};
inline constexpr FramebufferCreateFlags operator&(FramebufferCreateFlags lhs, FramebufferCreateFlags rhs) {
    return static_cast<FramebufferCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr FramebufferCreateFlags operator|(FramebufferCreateFlags lhs, FramebufferCreateFlags rhs) {
    return static_cast<FramebufferCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class FrontFace {
    CounterClockwise = 0,
    Clockwise = 1,
};

enum class ImageAspect {
    Color = 1u << 0u,
    Depth = 1u << 1u,
    Stencil = 1u << 2u,
    Metadata = 1u << 3u,
    Plane0 = 1u << 4u,
    Plane1 = 1u << 5u,
    Plane2 = 1u << 6u,
    None = 0,
};
inline constexpr ImageAspect operator&(ImageAspect lhs, ImageAspect rhs) {
    return static_cast<ImageAspect>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ImageAspect operator|(ImageAspect lhs, ImageAspect rhs) {
    return static_cast<ImageAspect>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ImageCreateFlags {
    None = 0,
    SparseBinding = 1u << 0u,
    SparseResidency = 1u << 1u,
    SparseAliased = 1u << 2u,
    MutableFormat = 1u << 3u,
    CubeCompatible = 1u << 4u,
    Alias = 1u << 10u,
    SplitInstanceBindRegions = 1u << 6u,
    _2DArrayCompatible = 1u << 5u,
    BlockTexelViewCompatible = 1u << 7u,
    ExtendedUsage = 1u << 8u,
    Protected = 1u << 11u,
    Disjoint = 1u << 9u,
    DescriptorBufferCaptureReplayEXT = 1u << 16u,
};
inline constexpr ImageCreateFlags operator&(ImageCreateFlags lhs, ImageCreateFlags rhs) {
    return static_cast<ImageCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ImageCreateFlags operator|(ImageCreateFlags lhs, ImageCreateFlags rhs) {
    return static_cast<ImageCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ImageLayout {
    Undefined = 0,
    General = 1,
    ColorAttachmentOptimal = 2,
    DepthStencilAttachmentOptimal = 3,
    DepthStencilReadOnlyOptimal = 4,
    ShaderReadOnlyOptimal = 5,
    TransferSrcOptimal = 6,
    TransferDstOptimal = 7,
    Preinitialized = 8,
    DepthReadOnlyStencilAttachmentOptimal = 1000117000,
    DepthAttachmentStencilReadOnlyOptimal = 1000117001,
    DepthAttachmentOptimal = 1000241000,
    DepthReadOnlyOptimal = 1000241001,
    StencilAttachmentOptimal = 1000241002,
    StencilReadOnlyOptimal = 1000241003,
    ReadOnlyOptimal = 1000314000,
    AttachmentOptimal = 1000314001,
    PresentSrcKHR = 1000001002,
};

enum class ImageTiling {
    Optimal = 0,
    Linear = 1,
};

enum class ImageType {
    _1D = 0,
    _2D = 1,
    _3D = 2,
};

enum class ImageUsage {
    TransferSrc = 1u << 0u,
    TransferDst = 1u << 1u,
    Sampled = 1u << 2u,
    Storage = 1u << 3u,
    ColorAttachment = 1u << 4u,
    DepthStencilAttachment = 1u << 5u,
    TransientAttachment = 1u << 6u,
    InputAttachment = 1u << 7u,
};
inline constexpr ImageUsage operator&(ImageUsage lhs, ImageUsage rhs) {
    return static_cast<ImageUsage>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ImageUsage operator|(ImageUsage lhs, ImageUsage rhs) {
    return static_cast<ImageUsage>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ImageViewCreateFlags {
    None = 0,
    DescriptorBufferCaptureReplayEXT = 1u << 2u,
};
inline constexpr ImageViewCreateFlags operator&(ImageViewCreateFlags lhs, ImageViewCreateFlags rhs) {
    return static_cast<ImageViewCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ImageViewCreateFlags operator|(ImageViewCreateFlags lhs, ImageViewCreateFlags rhs) {
    return static_cast<ImageViewCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ImageViewType {
    _1D = 0,
    _2D = 1,
    _3D = 2,
    Cube = 3,
    _1DArray = 4,
    _2DArray = 5,
    CubeArray = 6,
};

enum class IndexType {
    Uint16 = 0,
    Uint32 = 1,
};

enum class InternalAllocationType {
    Executable = 0,
};

enum class LogicOp {
    Clear = 0,
    And = 1,
    AndReverse = 2,
    Copy = 3,
    AndInverted = 4,
    NoOp = 5,
    Xor = 6,
    Or = 7,
    Nor = 8,
    Equivalent = 9,
    Invert = 10,
    OrReverse = 11,
    CopyInverted = 12,
    OrInverted = 13,
    Nand = 14,
    Set = 15,
};

enum class MemoryAllocateFlags {
    None = 0,
    DeviceMask = 1u << 0u,
    DeviceAddress = 1u << 1u,
    DeviceAddressCaptureReplay = 1u << 2u,
};
inline constexpr MemoryAllocateFlags operator&(MemoryAllocateFlags lhs, MemoryAllocateFlags rhs) {
    return static_cast<MemoryAllocateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr MemoryAllocateFlags operator|(MemoryAllocateFlags lhs, MemoryAllocateFlags rhs) {
    return static_cast<MemoryAllocateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class MemoryHeapFlags {
    None = 0,
    DeviceLocal = 1u << 0u,
    MultiInstance = 1u << 1u,
};
inline constexpr MemoryHeapFlags operator&(MemoryHeapFlags lhs, MemoryHeapFlags rhs) {
    return static_cast<MemoryHeapFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr MemoryHeapFlags operator|(MemoryHeapFlags lhs, MemoryHeapFlags rhs) {
    return static_cast<MemoryHeapFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class MemoryPropertyFlags {
    None = 0,
    DeviceLocal = 1u << 0u,
    HostVisible = 1u << 1u,
    HostCoherent = 1u << 2u,
    HostCached = 1u << 3u,
    LazilyAllocated = 1u << 4u,
    Protected = 1u << 5u,
};
inline constexpr MemoryPropertyFlags operator&(MemoryPropertyFlags lhs, MemoryPropertyFlags rhs) {
    return static_cast<MemoryPropertyFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr MemoryPropertyFlags operator|(MemoryPropertyFlags lhs, MemoryPropertyFlags rhs) {
    return static_cast<MemoryPropertyFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ObjectType {
    Unknown = 0,
    Instance = 1,
    PhysicalDevice = 2,
    Device = 3,
    Queue = 4,
    Semaphore = 5,
    CommandBuffer = 6,
    Fence = 7,
    DeviceMemory = 8,
    Buffer = 9,
    Image = 10,
    Event = 11,
    QueryPool = 12,
    BufferView = 13,
    ImageView = 14,
    ShaderModule = 15,
    PipelineCache = 16,
    PipelineLayout = 17,
    RenderPass = 18,
    Pipeline = 19,
    DescriptorSetLayout = 20,
    Sampler = 21,
    DescriptorPool = 22,
    DescriptorSet = 23,
    Framebuffer = 24,
    CommandPool = 25,
    SamplerYcbcrConversion = 1000156000,
    DescriptorUpdateTemplate = 1000085000,
    PrivateDataSlot = 1000295000,
    DebugUtilsMessengerEXT = 1000128000,
    SurfaceKHR = 1000000000,
    SwapchainKHR = 1000001000,
};

enum class PeerMemoryFeature {
    CopySrc = 1u << 0u,
    CopyDst = 1u << 1u,
    GenericSrc = 1u << 2u,
    GenericDst = 1u << 3u,
};
inline constexpr PeerMemoryFeature operator&(PeerMemoryFeature lhs, PeerMemoryFeature rhs) {
    return static_cast<PeerMemoryFeature>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr PeerMemoryFeature operator|(PeerMemoryFeature lhs, PeerMemoryFeature rhs) {
    return static_cast<PeerMemoryFeature>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class PhysicalDeviceType {
    Other = 0,
    IntegratedGpu = 1,
    DiscreteGpu = 2,
    VirtualGpu = 3,
    Cpu = 4,
};

enum class PipelineBindPoint {
    Graphics = 0,
    Compute = 1,
};

enum class PipelineCacheHeaderVersion {
    One = 1,
};

enum class PipelineCreateFlags {
    None = 0,
    DisableOptimization = 1u << 0u,
    AllowDerivatives = 1u << 1u,
    Derivative = 1u << 2u,
    ViewIndexFromDeviceIndex = 1u << 3u,
    DispatchBase = 1u << 4u,
    FailOnPipelineCompileRequired = 1u << 8u,
    EarlyReturnOnFailure = 1u << 9u,
    DescriptorBufferEXT = 1u << 29u,
};
inline constexpr PipelineCreateFlags operator&(PipelineCreateFlags lhs, PipelineCreateFlags rhs) {
    return static_cast<PipelineCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr PipelineCreateFlags operator|(PipelineCreateFlags lhs, PipelineCreateFlags rhs) {
    return static_cast<PipelineCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class PipelineCreationFeedbackFlags {
    None = 0,
    Valid = 1u << 0u,
    ApplicationPipelineCacheHit = 1u << 1u,
    BasePipelineAcceleration = 1u << 2u,
};
inline constexpr PipelineCreationFeedbackFlags operator&(PipelineCreationFeedbackFlags lhs, PipelineCreationFeedbackFlags rhs) {
    return static_cast<PipelineCreationFeedbackFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr PipelineCreationFeedbackFlags operator|(PipelineCreationFeedbackFlags lhs, PipelineCreationFeedbackFlags rhs) {
    return static_cast<PipelineCreationFeedbackFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class PipelineShaderStageCreateFlags {
    None = 0,
    AllowVaryingSubgroupSize = 1u << 0u,
    RequireFullSubgroups = 1u << 1u,
};
inline constexpr PipelineShaderStageCreateFlags operator&(PipelineShaderStageCreateFlags lhs, PipelineShaderStageCreateFlags rhs) {
    return static_cast<PipelineShaderStageCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr PipelineShaderStageCreateFlags operator|(PipelineShaderStageCreateFlags lhs, PipelineShaderStageCreateFlags rhs) {
    return static_cast<PipelineShaderStageCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class PipelineStage {
    TopOfPipe = 1u << 0u,
    DrawIndirect = 1u << 1u,
    VertexInput = 1u << 2u,
    VertexShader = 1u << 3u,
    TessellationControlShader = 1u << 4u,
    TessellationEvaluationShader = 1u << 5u,
    GeometryShader = 1u << 6u,
    FragmentShader = 1u << 7u,
    EarlyFragmentTests = 1u << 8u,
    LateFragmentTests = 1u << 9u,
    ColorAttachmentOutput = 1u << 10u,
    ComputeShader = 1u << 11u,
    Transfer = 1u << 12u,
    BottomOfPipe = 1u << 13u,
    Host = 1u << 14u,
    AllGraphics = 1u << 15u,
    AllCommands = 1u << 16u,
    None = 0,
};
inline constexpr PipelineStage operator&(PipelineStage lhs, PipelineStage rhs) {
    return static_cast<PipelineStage>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr PipelineStage operator|(PipelineStage lhs, PipelineStage rhs) {
    return static_cast<PipelineStage>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class PipelineStage2 : uint64_t {
    None = 0,
    TopOfPipe = 1ull << 0ull,
    DrawIndirect = 1ull << 1ull,
    VertexInput = 1ull << 2ull,
    VertexShader = 1ull << 3ull,
    TessellationControlShader = 1ull << 4ull,
    TessellationEvaluationShader = 1ull << 5ull,
    GeometryShader = 1ull << 6ull,
    FragmentShader = 1ull << 7ull,
    EarlyFragmentTests = 1ull << 8ull,
    LateFragmentTests = 1ull << 9ull,
    ColorAttachmentOutput = 1ull << 10ull,
    ComputeShader = 1ull << 11ull,
    AllTransfer = 1ull << 12ull,
    BottomOfPipe = 1ull << 13ull,
    Host = 1ull << 14ull,
    AllGraphics = 1ull << 15ull,
    AllCommands = 1ull << 16ull,
    Copy = 1ull << 32ull,
    Resolve = 1ull << 33ull,
    Blit = 1ull << 34ull,
    Clear = 1ull << 35ull,
    IndexInput = 1ull << 36ull,
    VertexAttributeInput = 1ull << 37ull,
    PreRasterizationShaders = 1ull << 38ull,
};
inline constexpr PipelineStage2 operator&(PipelineStage2 lhs, PipelineStage2 rhs) {
    return static_cast<PipelineStage2>(static_cast<uint64_t>(lhs) & static_cast<uint64_t>(rhs));
}
inline constexpr PipelineStage2 operator|(PipelineStage2 lhs, PipelineStage2 rhs) {
    return static_cast<PipelineStage2>(static_cast<uint64_t>(lhs) | static_cast<uint64_t>(rhs));
}

enum class PointClippingBehavior {
    AllClipPlanes = 0,
    UserClipPlanesOnly = 1,
};

enum class PolygonMode {
    Fill = 0,
    Line = 1,
    Point = 2,
};

enum class PresentModeKHR {
    Immediate = 0,
    Mailbox = 1,
    Fifo = 2,
    FifoRelaxed = 3,
};

enum class PrimitiveTopology {
    PointList = 0,
    LineList = 1,
    LineStrip = 2,
    TriangleList = 3,
    TriangleStrip = 4,
    TriangleFan = 5,
    LineListWithAdjacency = 6,
    LineStripWithAdjacency = 7,
    TriangleListWithAdjacency = 8,
    TriangleStripWithAdjacency = 9,
    PatchList = 10,
};

enum class QueryControlFlags {
    None = 0,
    Precise = 1u << 0u,
};
inline constexpr QueryControlFlags operator&(QueryControlFlags lhs, QueryControlFlags rhs) {
    return static_cast<QueryControlFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr QueryControlFlags operator|(QueryControlFlags lhs, QueryControlFlags rhs) {
    return static_cast<QueryControlFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class QueryPipelineStatisticFlags {
    None = 0,
    InputAssemblyVertices = 1u << 0u,
    InputAssemblyPrimitives = 1u << 1u,
    VertexShaderInvocations = 1u << 2u,
    GeometryShaderInvocations = 1u << 3u,
    GeometryShaderPrimitives = 1u << 4u,
    ClippingInvocations = 1u << 5u,
    ClippingPrimitives = 1u << 6u,
    FragmentShaderInvocations = 1u << 7u,
    TessellationControlShaderPatches = 1u << 8u,
    TessellationEvaluationShaderInvocations = 1u << 9u,
    ComputeShaderInvocations = 1u << 10u,
};
inline constexpr QueryPipelineStatisticFlags operator&(QueryPipelineStatisticFlags lhs, QueryPipelineStatisticFlags rhs) {
    return static_cast<QueryPipelineStatisticFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr QueryPipelineStatisticFlags operator|(QueryPipelineStatisticFlags lhs, QueryPipelineStatisticFlags rhs) {
    return static_cast<QueryPipelineStatisticFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class QueryResultFlags {
    None = 0,
    _64 = 1u << 0u,
    Wait = 1u << 1u,
    WithAvailability = 1u << 2u,
    Partial = 1u << 3u,
};
inline constexpr QueryResultFlags operator&(QueryResultFlags lhs, QueryResultFlags rhs) {
    return static_cast<QueryResultFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr QueryResultFlags operator|(QueryResultFlags lhs, QueryResultFlags rhs) {
    return static_cast<QueryResultFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class QueryType {
    Occlusion = 0,
    PipelineStatistics = 1,
    Timestamp = 2,
};

enum class QueueFlags {
    None = 0,
    Graphics = 1u << 0u,
    Compute = 1u << 1u,
    Transfer = 1u << 2u,
    SparseBinding = 1u << 3u,
    Protected = 1u << 4u,
};
inline constexpr QueueFlags operator&(QueueFlags lhs, QueueFlags rhs) {
    return static_cast<QueueFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr QueueFlags operator|(QueueFlags lhs, QueueFlags rhs) {
    return static_cast<QueueFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class RenderingFlags {
    None = 0,
    ContentsSecondaryCommandBuffers = 1u << 0u,
    Suspending = 1u << 1u,
    Resuming = 1u << 2u,
};
inline constexpr RenderingFlags operator&(RenderingFlags lhs, RenderingFlags rhs) {
    return static_cast<RenderingFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr RenderingFlags operator|(RenderingFlags lhs, RenderingFlags rhs) {
    return static_cast<RenderingFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ResolveMode {
    None = 0,
    SampleZero = 1u << 0u,
    Average = 1u << 1u,
    Min = 1u << 2u,
    Max = 1u << 3u,
};
inline constexpr ResolveMode operator&(ResolveMode lhs, ResolveMode rhs) {
    return static_cast<ResolveMode>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ResolveMode operator|(ResolveMode lhs, ResolveMode rhs) {
    return static_cast<ResolveMode>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class Result {
    Success = 0,
    NotReady = 1,
    Timeout = 2,
    EventSet = 3,
    EventReset = 4,
    Incomplete = 5,
    ErrorOutOfHostMemory = -1,
    ErrorOutOfDeviceMemory = -2,
    ErrorInitializationFailed = -3,
    ErrorDeviceLost = -4,
    ErrorMemoryMapFailed = -5,
    ErrorLayerNotPresent = -6,
    ErrorExtensionNotPresent = -7,
    ErrorFeatureNotPresent = -8,
    ErrorIncompatibleDriver = -9,
    ErrorTooManyObjects = -10,
    ErrorFormatNotSupported = -11,
    ErrorFragmentedPool = -12,
    ErrorUnknown = -13,
    ErrorOutOfPoolMemory = -1000069000,
    ErrorInvalidExternalHandle = -1000072003,
    ErrorFragmentation = -1000161000,
    ErrorInvalidOpaqueCaptureAddress = -1000257000,
    PipelineCompileRequired = 1000297000,
    ErrorSurfaceLostKHR = -1000000000,
    ErrorNativeWindowInUseKHR = -1000000001,
    SuboptimalKHR = 1000001003,
    ErrorOutOfDateKHR = -1000001004,
};

enum class SampleCount {
    _1 = 1u << 0u,
    _2 = 1u << 1u,
    _4 = 1u << 2u,
    _8 = 1u << 3u,
    _16 = 1u << 4u,
    _32 = 1u << 5u,
    _64 = 1u << 6u,
};
inline constexpr SampleCount operator&(SampleCount lhs, SampleCount rhs) {
    return static_cast<SampleCount>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SampleCount operator|(SampleCount lhs, SampleCount rhs) {
    return static_cast<SampleCount>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SamplerAddressMode {
    Repeat = 0,
    MirroredRepeat = 1,
    ClampToEdge = 2,
    ClampToBorder = 3,
    MirrorClampToEdge = 4,
};

enum class SamplerCreateFlags {
    None = 0,
    DescriptorBufferCaptureReplayEXT = 1u << 3u,
};
inline constexpr SamplerCreateFlags operator&(SamplerCreateFlags lhs, SamplerCreateFlags rhs) {
    return static_cast<SamplerCreateFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SamplerCreateFlags operator|(SamplerCreateFlags lhs, SamplerCreateFlags rhs) {
    return static_cast<SamplerCreateFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SamplerMipmapMode {
    Nearest = 0,
    Linear = 1,
};

enum class SamplerReductionMode {
    WeightedAverage = 0,
    Min = 1,
    Max = 2,
};

enum class SamplerYcbcrModelConversion {
    RgbIdentity = 0,
    YcbcrIdentity = 1,
    Ycbcr709 = 2,
    Ycbcr601 = 3,
    Ycbcr2020 = 4,
};

enum class SamplerYcbcrRange {
    ItuFull = 0,
    ItuNarrow = 1,
};

enum class SemaphoreImportFlags {
    None = 0,
    Temporary = 1u << 0u,
};
inline constexpr SemaphoreImportFlags operator&(SemaphoreImportFlags lhs, SemaphoreImportFlags rhs) {
    return static_cast<SemaphoreImportFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SemaphoreImportFlags operator|(SemaphoreImportFlags lhs, SemaphoreImportFlags rhs) {
    return static_cast<SemaphoreImportFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SemaphoreType {
    Binary = 0,
    Timeline = 1,
};

enum class SemaphoreWaitFlags {
    None = 0,
    Any = 1u << 0u,
};
inline constexpr SemaphoreWaitFlags operator&(SemaphoreWaitFlags lhs, SemaphoreWaitFlags rhs) {
    return static_cast<SemaphoreWaitFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SemaphoreWaitFlags operator|(SemaphoreWaitFlags lhs, SemaphoreWaitFlags rhs) {
    return static_cast<SemaphoreWaitFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ShaderFloatControlsIndependence {
    _32Only = 0,
    All = 1,
    None = 2,
};

enum class ShaderStage {
    Vertex = 1u << 0u,
    TessellationControl = 1u << 1u,
    TessellationEvaluation = 1u << 2u,
    Geometry = 1u << 3u,
    Fragment = 1u << 4u,
    Compute = 1u << 5u,
    AllGraphics = 0x0000001F,
    All = 0x7FFFFFFF,
};
inline constexpr ShaderStage operator&(ShaderStage lhs, ShaderStage rhs) {
    return static_cast<ShaderStage>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ShaderStage operator|(ShaderStage lhs, ShaderStage rhs) {
    return static_cast<ShaderStage>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SharingMode {
    Exclusive = 0,
    Concurrent = 1,
};

enum class SparseImageFormatFlags {
    None = 0,
    SingleMiptail = 1u << 0u,
    AlignedMipSize = 1u << 1u,
    NonstandardBlockSize = 1u << 2u,
};
inline constexpr SparseImageFormatFlags operator&(SparseImageFormatFlags lhs, SparseImageFormatFlags rhs) {
    return static_cast<SparseImageFormatFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SparseImageFormatFlags operator|(SparseImageFormatFlags lhs, SparseImageFormatFlags rhs) {
    return static_cast<SparseImageFormatFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SparseMemoryBindFlags {
    None = 0,
    Metadata = 1u << 0u,
};
inline constexpr SparseMemoryBindFlags operator&(SparseMemoryBindFlags lhs, SparseMemoryBindFlags rhs) {
    return static_cast<SparseMemoryBindFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SparseMemoryBindFlags operator|(SparseMemoryBindFlags lhs, SparseMemoryBindFlags rhs) {
    return static_cast<SparseMemoryBindFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class StencilFaceFlags {
    None = 0,
    Front = 1u << 0u,
    Back = 1u << 1u,
    FrontAndBack = 0x00000003,
};
inline constexpr StencilFaceFlags operator&(StencilFaceFlags lhs, StencilFaceFlags rhs) {
    return static_cast<StencilFaceFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr StencilFaceFlags operator|(StencilFaceFlags lhs, StencilFaceFlags rhs) {
    return static_cast<StencilFaceFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class StencilOp {
    Keep = 0,
    Zero = 1,
    Replace = 2,
    IncrementAndClamp = 3,
    DecrementAndClamp = 4,
    Invert = 5,
    IncrementAndWrap = 6,
    DecrementAndWrap = 7,
};

enum class StructureType {
    ApplicationInfo = 0,
    InstanceCreateInfo = 1,
    DeviceQueueCreateInfo = 2,
    DeviceCreateInfo = 3,
    SubmitInfo = 4,
    MemoryAllocateInfo = 5,
    MappedMemoryRange = 6,
    BindSparseInfo = 7,
    FenceCreateInfo = 8,
    SemaphoreCreateInfo = 9,
    EventCreateInfo = 10,
    QueryPoolCreateInfo = 11,
    BufferCreateInfo = 12,
    BufferViewCreateInfo = 13,
    ImageCreateInfo = 14,
    ImageViewCreateInfo = 15,
    ShaderModuleCreateInfo = 16,
    PipelineCacheCreateInfo = 17,
    PipelineShaderStageCreateInfo = 18,
    PipelineVertexInputStateCreateInfo = 19,
    PipelineInputAssemblyStateCreateInfo = 20,
    PipelineTessellationStateCreateInfo = 21,
    PipelineViewportStateCreateInfo = 22,
    PipelineRasterizationStateCreateInfo = 23,
    PipelineMultisampleStateCreateInfo = 24,
    PipelineDepthStencilStateCreateInfo = 25,
    PipelineColorBlendStateCreateInfo = 26,
    PipelineDynamicStateCreateInfo = 27,
    GraphicsPipelineCreateInfo = 28,
    ComputePipelineCreateInfo = 29,
    PipelineLayoutCreateInfo = 30,
    SamplerCreateInfo = 31,
    DescriptorSetLayoutCreateInfo = 32,
    DescriptorPoolCreateInfo = 33,
    DescriptorSetAllocateInfo = 34,
    WriteDescriptorSet = 35,
    CopyDescriptorSet = 36,
    FramebufferCreateInfo = 37,
    RenderPassCreateInfo = 38,
    CommandPoolCreateInfo = 39,
    CommandBufferAllocateInfo = 40,
    CommandBufferInheritanceInfo = 41,
    CommandBufferBeginInfo = 42,
    RenderPassBeginInfo = 43,
    BufferMemoryBarrier = 44,
    ImageMemoryBarrier = 45,
    MemoryBarrier = 46,
    LoaderInstanceCreateInfo = 47,
    LoaderDeviceCreateInfo = 48,
    PhysicalDeviceSubgroupProperties = 1000094000,
    BindBufferMemoryInfo = 1000157000,
    BindImageMemoryInfo = 1000157001,
    PhysicalDevice16StorageFeatures = 1000083000,
    MemoryDedicatedRequirements = 1000127000,
    MemoryDedicatedAllocateInfo = 1000127001,
    MemoryAllocateFlagsInfo = 1000060000,
    DeviceGroupRenderPassBeginInfo = 1000060003,
    DeviceGroupCommandBufferBeginInfo = 1000060004,
    DeviceGroupSubmitInfo = 1000060005,
    DeviceGroupBindSparseInfo = 1000060006,
    BindBufferMemoryDeviceGroupInfo = 1000060013,
    BindImageMemoryDeviceGroupInfo = 1000060014,
    PhysicalDeviceGroupProperties = 1000070000,
    DeviceGroupDeviceCreateInfo = 1000070001,
    BufferMemoryRequirementsInfo2 = 1000146000,
    ImageMemoryRequirementsInfo2 = 1000146001,
    ImageSparseMemoryRequirementsInfo2 = 1000146002,
    MemoryRequirements2 = 1000146003,
    SparseImageMemoryRequirements2 = 1000146004,
    PhysicalDeviceFeatures2 = 1000059000,
    PhysicalDeviceProperties2 = 1000059001,
    FormatProperties2 = 1000059002,
    ImageFormatProperties2 = 1000059003,
    PhysicalDeviceImageFormatInfo2 = 1000059004,
    QueueFamilyProperties2 = 1000059005,
    PhysicalDeviceMemoryProperties2 = 1000059006,
    SparseImageFormatProperties2 = 1000059007,
    PhysicalDeviceSparseImageFormatInfo2 = 1000059008,
    PhysicalDevicePointClippingProperties = 1000117000,
    RenderPassInputAttachmentAspectCreateInfo = 1000117001,
    ImageViewUsageCreateInfo = 1000117002,
    PipelineTessellationDomainOriginStateCreateInfo = 1000117003,
    RenderPassMultiviewCreateInfo = 1000053000,
    PhysicalDeviceMultiviewFeatures = 1000053001,
    PhysicalDeviceMultiviewProperties = 1000053002,
    PhysicalDeviceVariablePointersFeatures = 1000120000,
    ProtectedSubmitInfo = 1000145000,
    PhysicalDeviceProtectedMemoryFeatures = 1000145001,
    PhysicalDeviceProtectedMemoryProperties = 1000145002,
    DeviceQueueInfo2 = 1000145003,
    SamplerYcbcrConversionCreateInfo = 1000156000,
    SamplerYcbcrConversionInfo = 1000156001,
    BindImagePlaneMemoryInfo = 1000156002,
    ImagePlaneMemoryRequirementsInfo = 1000156003,
    PhysicalDeviceSamplerYcbcrConversionFeatures = 1000156004,
    SamplerYcbcrConversionImageFormatProperties = 1000156005,
    DescriptorUpdateTemplateCreateInfo = 1000085000,
    PhysicalDeviceExternalImageFormatInfo = 1000071000,
    ExternalImageFormatProperties = 1000071001,
    PhysicalDeviceExternalBufferInfo = 1000071002,
    ExternalBufferProperties = 1000071003,
    PhysicalDeviceIdProperties = 1000071004,
    ExternalMemoryBufferCreateInfo = 1000072000,
    ExternalMemoryImageCreateInfo = 1000072001,
    ExportMemoryAllocateInfo = 1000072002,
    PhysicalDeviceExternalFenceInfo = 1000112000,
    ExternalFenceProperties = 1000112001,
    ExportFenceCreateInfo = 1000113000,
    ExportSemaphoreCreateInfo = 1000077000,
    PhysicalDeviceExternalSemaphoreInfo = 1000076000,
    ExternalSemaphoreProperties = 1000076001,
    PhysicalDeviceMaintenance3Properties = 1000168000,
    DescriptorSetLayoutSupport = 1000168001,
    PhysicalDeviceShaderDrawParametersFeatures = 1000063000,
    PhysicalDeviceVulkan11Features = 49,
    PhysicalDeviceVulkan11Properties = 50,
    PhysicalDeviceVulkan12Features = 51,
    PhysicalDeviceVulkan12Properties = 52,
    ImageFormatListCreateInfo = 1000147000,
    AttachmentDescription2 = 1000109000,
    AttachmentReference2 = 1000109001,
    SubpassDescription2 = 1000109002,
    SubpassDependency2 = 1000109003,
    RenderPassCreateInfo2 = 1000109004,
    SubpassBeginInfo = 1000109005,
    SubpassEndInfo = 1000109006,
    PhysicalDevice8StorageFeatures = 1000177000,
    PhysicalDeviceDriverProperties = 1000196000,
    PhysicalDeviceShaderAtomicInt64Features = 1000180000,
    PhysicalDeviceShaderFloat16Int8Features = 1000082000,
    PhysicalDeviceFloatControlsProperties = 1000197000,
    DescriptorSetLayoutBindingFlagsCreateInfo = 1000161000,
    PhysicalDeviceDescriptorIndexingFeatures = 1000161001,
    PhysicalDeviceDescriptorIndexingProperties = 1000161002,
    DescriptorSetVariableDescriptorCountAllocateInfo = 1000161003,
    DescriptorSetVariableDescriptorCountLayoutSupport = 1000161004,
    PhysicalDeviceDepthStencilResolveProperties = 1000199000,
    SubpassDescriptionDepthStencilResolve = 1000199001,
    PhysicalDeviceScalarBlockLayoutFeatures = 1000221000,
    ImageStencilUsageCreateInfo = 1000246000,
    PhysicalDeviceSamplerFilterMinmaxProperties = 1000130000,
    SamplerReductionModeCreateInfo = 1000130001,
    PhysicalDeviceVulkanMemoryModelFeatures = 1000211000,
    PhysicalDeviceImagelessFramebufferFeatures = 1000108000,
    FramebufferAttachmentsCreateInfo = 1000108001,
    FramebufferAttachmentImageInfo = 1000108002,
    RenderPassAttachmentBeginInfo = 1000108003,
    PhysicalDeviceUniformBufferStandardLayoutFeatures = 1000253000,
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures = 1000175000,
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures = 1000241000,
    AttachmentReferenceStencilLayout = 1000241001,
    AttachmentDescriptionStencilLayout = 1000241002,
    PhysicalDeviceHostQueryResetFeatures = 1000261000,
    PhysicalDeviceTimelineSemaphoreFeatures = 1000207000,
    PhysicalDeviceTimelineSemaphoreProperties = 1000207001,
    SemaphoreTypeCreateInfo = 1000207002,
    TimelineSemaphoreSubmitInfo = 1000207003,
    SemaphoreWaitInfo = 1000207004,
    SemaphoreSignalInfo = 1000207005,
    PhysicalDeviceBufferDeviceAddressFeatures = 1000257000,
    BufferDeviceAddressInfo = 1000244001,
    BufferOpaqueCaptureAddressCreateInfo = 1000257002,
    MemoryOpaqueCaptureAddressAllocateInfo = 1000257003,
    DeviceMemoryOpaqueCaptureAddressInfo = 1000257004,
    PhysicalDeviceVulkan13Features = 53,
    PhysicalDeviceVulkan13Properties = 54,
    PipelineCreationFeedbackCreateInfo = 1000192000,
    PhysicalDeviceShaderTerminateInvocationFeatures = 1000215000,
    PhysicalDeviceToolProperties = 1000245000,
    PhysicalDeviceShaderDemoteToHelperInvocationFeatures = 1000276000,
    PhysicalDevicePrivateDataFeatures = 1000295000,
    DevicePrivateDataCreateInfo = 1000295001,
    PrivateDataSlotCreateInfo = 1000295002,
    PhysicalDevicePipelineCreationCacheControlFeatures = 1000297000,
    MemoryBarrier2 = 1000314000,
    BufferMemoryBarrier2 = 1000314001,
    ImageMemoryBarrier2 = 1000314002,
    DependencyInfo = 1000314003,
    SubmitInfo2 = 1000314004,
    SemaphoreSubmitInfo = 1000314005,
    CommandBufferSubmitInfo = 1000314006,
    PhysicalDeviceSynchronization2Features = 1000314007,
    PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures = 1000325000,
    PhysicalDeviceImageRobustnessFeatures = 1000335000,
    CopyBufferInfo2 = 1000337000,
    CopyImageInfo2 = 1000337001,
    CopyBufferToImageInfo2 = 1000337002,
    CopyImageToBufferInfo2 = 1000337003,
    BlitImageInfo2 = 1000337004,
    ResolveImageInfo2 = 1000337005,
    BufferCopy2 = 1000337006,
    ImageCopy2 = 1000337007,
    ImageBlit2 = 1000337008,
    BufferImageCopy2 = 1000337009,
    ImageResolve2 = 1000337010,
    PhysicalDeviceSubgroupSizeControlProperties = 1000225000,
    PipelineShaderStageRequiredSubgroupSizeCreateInfo = 1000225001,
    PhysicalDeviceSubgroupSizeControlFeatures = 1000225002,
    PhysicalDeviceInlineUniformBlockFeatures = 1000138000,
    PhysicalDeviceInlineUniformBlockProperties = 1000138001,
    WriteDescriptorSetInlineUniformBlock = 1000138002,
    DescriptorPoolInlineUniformBlockCreateInfo = 1000138003,
    PhysicalDeviceTextureCompressionAstcHdrFeatures = 1000066000,
    RenderingInfo = 1000044000,
    RenderingAttachmentInfo = 1000044001,
    PipelineRenderingCreateInfo = 1000044002,
    PhysicalDeviceDynamicRenderingFeatures = 1000044003,
    CommandBufferInheritanceRenderingInfo = 1000044004,
    PhysicalDeviceShaderIntegerDotProductFeatures = 1000280000,
    PhysicalDeviceShaderIntegerDotProductProperties = 1000280001,
    PhysicalDeviceTexelBufferAlignmentProperties = 1000281001,
    FormatProperties3 = 1000360000,
    PhysicalDeviceMaintenance4Features = 1000413000,
    PhysicalDeviceMaintenance4Properties = 1000413001,
    DeviceBufferMemoryRequirements = 1000413002,
    DeviceImageMemoryRequirements = 1000413003,
    DebugUtilsObjectNameInfoEXT = 1000128000,
    DebugUtilsObjectTagInfoEXT = 1000128001,
    DebugUtilsLabelEXT = 1000128002,
    DebugUtilsMessengerCallbackDataEXT = 1000128003,
    DebugUtilsMessengerCreateInfoEXT = 1000128004,
    PhysicalDeviceDescriptorBufferPropertiesEXT = 1000316000,
    PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT = 1000316001,
    PhysicalDeviceDescriptorBufferFeaturesEXT = 1000316002,
    DescriptorAddressInfoEXT = 1000316003,
    DescriptorGetInfoEXT = 1000316004,
    BufferCaptureDescriptorDataInfoEXT = 1000316005,
    ImageCaptureDescriptorDataInfoEXT = 1000316006,
    ImageViewCaptureDescriptorDataInfoEXT = 1000316007,
    SamplerCaptureDescriptorDataInfoEXT = 1000316008,
    OpaqueCaptureDescriptorDataCreateInfoEXT = 1000316010,
    DescriptorBufferBindingInfoEXT = 1000316011,
    DescriptorBufferBindingPushDescriptorBufferHandleEXT = 1000316012,
    PhysicalDeviceShaderAtomicFloatFeaturesEXT = 1000260000,
    PhysicalDeviceShaderAtomicFloat2FeaturesEXT = 1000273000,
    ValidationFeaturesEXT = 1000247000,
    SwapchainCreateInfoKHR = 1000001000,
    PresentInfoKHR = 1000001001,
    DeviceGroupPresentCapabilitiesKHR = 1000060007,
    ImageSwapchainCreateInfoKHR = 1000060008,
    BindImageMemorySwapchainInfoKHR = 1000060009,
    AcquireNextImageInfoKHR = 1000060010,
    DeviceGroupPresentInfoKHR = 1000060011,
    DeviceGroupSwapchainCreateInfoKHR = 1000060012,
    XcbSurfaceCreateInfoKHR = 1000005000,
};

enum class SubgroupFeature {
    Basic = 1u << 0u,
    Vote = 1u << 1u,
    Arithmetic = 1u << 2u,
    Ballot = 1u << 3u,
    Shuffle = 1u << 4u,
    ShuffleRelative = 1u << 5u,
    Clustered = 1u << 6u,
    Quad = 1u << 7u,
};
inline constexpr SubgroupFeature operator&(SubgroupFeature lhs, SubgroupFeature rhs) {
    return static_cast<SubgroupFeature>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SubgroupFeature operator|(SubgroupFeature lhs, SubgroupFeature rhs) {
    return static_cast<SubgroupFeature>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SubmitFlags {
    None = 0,
    Protected = 1u << 0u,
};
inline constexpr SubmitFlags operator&(SubmitFlags lhs, SubmitFlags rhs) {
    return static_cast<SubmitFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SubmitFlags operator|(SubmitFlags lhs, SubmitFlags rhs) {
    return static_cast<SubmitFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SubpassContents {
    Inline = 0,
    SecondaryCommandBuffers = 1,
};

enum class SurfaceTransformFlagsKHR {
    Identity = 1u << 0u,
    Rotate90 = 1u << 1u,
    Rotate180 = 1u << 2u,
    Rotate270 = 1u << 3u,
    HorizontalMirror = 1u << 4u,
    HorizontalMirrorRotate90 = 1u << 5u,
    HorizontalMirrorRotate180 = 1u << 6u,
    HorizontalMirrorRotate270 = 1u << 7u,
    Inherit = 1u << 8u,
};
inline constexpr SurfaceTransformFlagsKHR operator&(SurfaceTransformFlagsKHR lhs, SurfaceTransformFlagsKHR rhs) {
    return static_cast<SurfaceTransformFlagsKHR>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SurfaceTransformFlagsKHR operator|(SurfaceTransformFlagsKHR lhs, SurfaceTransformFlagsKHR rhs) {
    return static_cast<SurfaceTransformFlagsKHR>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SwapchainCreateFlagsKHR {
    SplitInstanceBindRegions = 1u << 0u,
    Protected = 1u << 1u,
};
inline constexpr SwapchainCreateFlagsKHR operator&(SwapchainCreateFlagsKHR lhs, SwapchainCreateFlagsKHR rhs) {
    return static_cast<SwapchainCreateFlagsKHR>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr SwapchainCreateFlagsKHR operator|(SwapchainCreateFlagsKHR lhs, SwapchainCreateFlagsKHR rhs) {
    return static_cast<SwapchainCreateFlagsKHR>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class SystemAllocationScope {
    Command = 0,
    Object = 1,
    Cache = 2,
    Device = 3,
    Instance = 4,
};

enum class TessellationDomainOrigin {
    UpperLeft = 0,
    LowerLeft = 1,
};

enum class ToolPurposeFlags {
    None = 0,
    Validation = 1u << 0u,
    Profiling = 1u << 1u,
    Tracing = 1u << 2u,
    AdditionalFeatures = 1u << 3u,
    ModifyingFeatures = 1u << 4u,
};
inline constexpr ToolPurposeFlags operator&(ToolPurposeFlags lhs, ToolPurposeFlags rhs) {
    return static_cast<ToolPurposeFlags>(static_cast<uint32_t>(lhs) & static_cast<uint32_t>(rhs));
}
inline constexpr ToolPurposeFlags operator|(ToolPurposeFlags lhs, ToolPurposeFlags rhs) {
    return static_cast<ToolPurposeFlags>(static_cast<uint32_t>(lhs) | static_cast<uint32_t>(rhs));
}

enum class ValidationFeatureDisableEXT {
    All = 0,
    Shaders = 1,
    ThreadSafety = 2,
    ApiParameters = 3,
    ObjectLifetimes = 4,
    CoreChecks = 5,
    UniqueHandles = 6,
    ShaderValidationCache = 7,
};

enum class ValidationFeatureEnableEXT {
    GpuAssisted = 0,
    GpuAssistedReserveBindingSlot = 1,
    BestPractices = 2,
    DebugPrintf = 3,
    SynchronizationValidation = 4,
};

enum class VendorId {
    Khronos = 0x10000,
    VIV = 0x10001,
    VSI = 0x10002,
    Kazan = 0x10003,
    Codeplay = 0x10004,
    MESA = 0x10005,
    Pocl = 0x10006,
    Mobileye = 0x10007,
};

enum class VertexInputRate {
    Vertex = 0,
    Instance = 1,
};

// Structs and unions.
struct BufferMemoryBarrier {
    StructureType sType;
    const void *pNext;
    Access srcAccessMask;
    Access dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    Buffer buffer;
    DeviceSize offset;
    DeviceSize size;
};

struct DispatchIndirectCommand {
    uint32_t x;
    uint32_t y;
    uint32_t z;
};

struct DrawIndexedIndirectCommand {
    uint32_t indexCount;
    uint32_t instanceCount;
    uint32_t firstIndex;
    int32_t vertexOffset;
    uint32_t firstInstance;
};

struct DrawIndirectCommand {
    uint32_t vertexCount;
    uint32_t instanceCount;
    uint32_t firstVertex;
    uint32_t firstInstance;
};

struct ImageSubresourceRange {
    ImageAspect aspectMask;
    uint32_t baseMipLevel;
    uint32_t levelCount;
    uint32_t baseArrayLayer;
    uint32_t layerCount;
};

struct ImageMemoryBarrier {
    StructureType sType;
    const void *pNext;
    Access srcAccessMask;
    Access dstAccessMask;
    ImageLayout oldLayout;
    ImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    Image image;
    ImageSubresourceRange subresourceRange;
};

struct MemoryBarrier {
    StructureType sType;
    const void *pNext;
    Access srcAccessMask;
    Access dstAccessMask;
};

struct PipelineCacheHeaderVersionOne {
    uint32_t headerSize;
    PipelineCacheHeaderVersion headerVersion;
    uint32_t vendorID;
    uint32_t deviceID;
    uint8_t pipelineCacheUUID [k_uuid_size ];
};

typedef void (VKAPI_PTR *PFN_vkVoidFunction)(void); 

typedef void* (VKAPI_PTR *PFN_vkAllocationFunction)(
    void*                                       pUserData,
    size_t                                      size,
    size_t                                      alignment,
    SystemAllocationScope                     allocationScope); 

typedef void* (VKAPI_PTR *PFN_vkReallocationFunction)(
    void*                                       pUserData,
    void*                                       pOriginal,
    size_t                                      size,
    size_t                                      alignment,
    SystemAllocationScope                     allocationScope); 

typedef void (VKAPI_PTR *PFN_vkFreeFunction)(
    void*                                       pUserData,
    void*                                       pMemory); 

typedef void (VKAPI_PTR *PFN_vkInternalAllocationNotification)(
    void*                                       pUserData,
    size_t                                      size,
    InternalAllocationType                    allocationType,
    SystemAllocationScope                     allocationScope); 

typedef void (VKAPI_PTR *PFN_vkInternalFreeNotification)(
    void*                                       pUserData,
    size_t                                      size,
    InternalAllocationType                    allocationType,
    SystemAllocationScope                     allocationScope); 

struct AllocationCallbacks {
    void *pUserData;
    PFN_vkAllocationFunction pfnAllocation;
    PFN_vkReallocationFunction pfnReallocation;
    PFN_vkFreeFunction pfnFree;
    PFN_vkInternalAllocationNotification pfnInternalAllocation;
    PFN_vkInternalFreeNotification pfnInternalFree;
};

struct ApplicationInfo {
    StructureType sType;
    const void *pNext;
    const char *pApplicationName;
    uint32_t applicationVersion;
    const char *pEngineName;
    uint32_t engineVersion;
    uint32_t apiVersion;
};

struct InstanceCreateInfo {
    StructureType sType;
    const void *pNext;
    InstanceCreateFlags flags;
    const ApplicationInfo *pApplicationInfo;
    uint32_t enabledLayerCount;
    const char * const*ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    const char * const*ppEnabledExtensionNames;
};

struct DeviceQueueCreateInfo {
    StructureType sType;
    const void *pNext;
    DeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueCount;
    const float *pQueuePriorities;
};

struct PhysicalDeviceFeatures {
    Bool robustBufferAccess;
    Bool fullDrawIndexUint32;
    Bool imageCubeArray;
    Bool independentBlend;
    Bool geometryShader;
    Bool tessellationShader;
    Bool sampleRateShading;
    Bool dualSrcBlend;
    Bool logicOp;
    Bool multiDrawIndirect;
    Bool drawIndirectFirstInstance;
    Bool depthClamp;
    Bool depthBiasClamp;
    Bool fillModeNonSolid;
    Bool depthBounds;
    Bool wideLines;
    Bool largePoints;
    Bool alphaToOne;
    Bool multiViewport;
    Bool samplerAnisotropy;
    Bool textureCompressionETC2;
    Bool textureCompressionASTC_LDR;
    Bool textureCompressionBC;
    Bool occlusionQueryPrecise;
    Bool pipelineStatisticsQuery;
    Bool vertexPipelineStoresAndAtomics;
    Bool fragmentStoresAndAtomics;
    Bool shaderTessellationAndGeometryPointSize;
    Bool shaderImageGatherExtended;
    Bool shaderStorageImageExtendedFormats;
    Bool shaderStorageImageMultisample;
    Bool shaderStorageImageReadWithoutFormat;
    Bool shaderStorageImageWriteWithoutFormat;
    Bool shaderUniformBufferArrayDynamicIndexing;
    Bool shaderSampledImageArrayDynamicIndexing;
    Bool shaderStorageBufferArrayDynamicIndexing;
    Bool shaderStorageImageArrayDynamicIndexing;
    Bool shaderClipDistance;
    Bool shaderCullDistance;
    Bool shaderFloat64;
    Bool shaderInt64;
    Bool shaderInt16;
    Bool shaderResourceResidency;
    Bool shaderResourceMinLod;
    Bool sparseBinding;
    Bool sparseResidencyBuffer;
    Bool sparseResidencyImage2D;
    Bool sparseResidencyImage3D;
    Bool sparseResidency2Samples;
    Bool sparseResidency4Samples;
    Bool sparseResidency8Samples;
    Bool sparseResidency16Samples;
    Bool sparseResidencyAliased;
    Bool variableMultisampleRate;
    Bool inheritedQueries;
};

struct DeviceCreateInfo {
    StructureType sType;
    const void *pNext;
    DeviceCreateFlags flags;
    uint32_t queueCreateInfoCount;
    const DeviceQueueCreateInfo *pQueueCreateInfos;
    uint32_t enabledLayerCount;
    const char * const*ppEnabledLayerNames;
    uint32_t enabledExtensionCount;
    const char * const*ppEnabledExtensionNames;
    const PhysicalDeviceFeatures *pEnabledFeatures;
};

struct ExtensionProperties {
    char extensionName [k_max_extension_name_size ];
    uint32_t specVersion;
};

struct LayerProperties {
    char layerName [k_max_extension_name_size ];
    uint32_t specVersion;
    uint32_t implementationVersion;
    char description [k_max_description_size ];
};

struct SubmitInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const Semaphore *pWaitSemaphores;
    const PipelineStage *pWaitDstStageMask;
    uint32_t commandBufferCount;
    const CommandBuffer *pCommandBuffers;
    uint32_t signalSemaphoreCount;
    const Semaphore *pSignalSemaphores;
};

struct MappedMemoryRange {
    StructureType sType;
    const void *pNext;
    DeviceMemory memory;
    DeviceSize offset;
    DeviceSize size;
};

struct MemoryAllocateInfo {
    StructureType sType;
    const void *pNext;
    DeviceSize allocationSize;
    uint32_t memoryTypeIndex;
};

struct SparseMemoryBind {
    DeviceSize resourceOffset;
    DeviceSize size;
    DeviceMemory memory;
    DeviceSize memoryOffset;
    SparseMemoryBindFlags flags;
};

struct SparseBufferMemoryBindInfo {
    Buffer buffer;
    uint32_t bindCount;
    const SparseMemoryBind *pBinds;
};

struct SparseImageOpaqueMemoryBindInfo {
    Image image;
    uint32_t bindCount;
    const SparseMemoryBind *pBinds;
};

struct ImageSubresource {
    ImageAspect aspectMask;
    uint32_t mipLevel;
    uint32_t arrayLayer;
};

struct Offset3D {
    int32_t x;
    int32_t y;
    int32_t z;
};

struct Extent3D {
    uint32_t width;
    uint32_t height;
    uint32_t depth;
};

struct SparseImageMemoryBind {
    ImageSubresource subresource;
    Offset3D offset;
    Extent3D extent;
    DeviceMemory memory;
    DeviceSize memoryOffset;
    SparseMemoryBindFlags flags;
};

struct SparseImageMemoryBindInfo {
    Image image;
    uint32_t bindCount;
    const SparseImageMemoryBind *pBinds;
};

struct BindSparseInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const Semaphore *pWaitSemaphores;
    uint32_t bufferBindCount;
    const SparseBufferMemoryBindInfo *pBufferBinds;
    uint32_t imageOpaqueBindCount;
    const SparseImageOpaqueMemoryBindInfo *pImageOpaqueBinds;
    uint32_t imageBindCount;
    const SparseImageMemoryBindInfo *pImageBinds;
    uint32_t signalSemaphoreCount;
    const Semaphore *pSignalSemaphores;
};

struct FenceCreateInfo {
    StructureType sType;
    const void *pNext;
    FenceCreateFlags flags;
};

struct SemaphoreCreateInfo {
    StructureType sType;
    const void *pNext;
    SemaphoreCreateFlags flags;
};

struct EventCreateInfo {
    StructureType sType;
    const void *pNext;
    EventCreateFlags flags;
};

struct QueryPoolCreateInfo {
    StructureType sType;
    const void *pNext;
    QueryPoolCreateFlags flags;
    QueryType queryType;
    uint32_t queryCount;
    QueryPipelineStatisticFlags pipelineStatistics;
};

struct BufferViewCreateInfo {
    StructureType sType;
    const void *pNext;
    BufferViewCreateFlags flags;
    Buffer buffer;
    Format format;
    DeviceSize offset;
    DeviceSize range;
};

struct SubresourceLayout {
    DeviceSize offset;
    DeviceSize size;
    DeviceSize rowPitch;
    DeviceSize arrayPitch;
    DeviceSize depthPitch;
};

struct ComponentMapping {
    ComponentSwizzle r;
    ComponentSwizzle g;
    ComponentSwizzle b;
    ComponentSwizzle a;
};

struct ImageViewCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageViewCreateFlags flags;
    Image image;
    ImageViewType viewType;
    Format format;
    ComponentMapping components;
    ImageSubresourceRange subresourceRange;
};

struct ShaderModuleCreateInfo {
    StructureType sType;
    const void *pNext;
    ShaderModuleCreateFlags flags;
    size_t codeSize;
    const uint32_t *pCode;
};

struct PipelineCacheCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCacheCreateFlags flags;
    size_t initialDataSize;
    const void *pInitialData;
};

struct SpecializationMapEntry {
    uint32_t constantID;
    uint32_t offset;
    size_t size;
};

struct SpecializationInfo {
    uint32_t mapEntryCount;
    const SpecializationMapEntry *pMapEntries;
    size_t dataSize;
    const void *pData;
};

struct PipelineShaderStageCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineShaderStageCreateFlags flags;
    ShaderStage stage;
    ShaderModule module;
    const char *pName;
    const SpecializationInfo *pSpecializationInfo;
};

struct ComputePipelineCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCreateFlags flags;
    PipelineShaderStageCreateInfo stage;
    PipelineLayout layout;
    Pipeline basePipelineHandle;
    int32_t basePipelineIndex;
};

struct VertexInputBindingDescription {
    uint32_t binding;
    uint32_t stride;
    VertexInputRate inputRate;
};

struct VertexInputAttributeDescription {
    uint32_t location;
    uint32_t binding;
    Format format;
    uint32_t offset;
};

struct PipelineVertexInputStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineVertexInputStateCreateFlags flags;
    uint32_t vertexBindingDescriptionCount;
    const VertexInputBindingDescription *pVertexBindingDescriptions;
    uint32_t vertexAttributeDescriptionCount;
    const VertexInputAttributeDescription *pVertexAttributeDescriptions;
};

struct PipelineInputAssemblyStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineInputAssemblyStateCreateFlags flags;
    PrimitiveTopology topology;
    Bool primitiveRestartEnable;
};

struct PipelineTessellationStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineTessellationStateCreateFlags flags;
    uint32_t patchControlPoints;
};

struct Viewport {
    float x;
    float y;
    float width;
    float height;
    float minDepth;
    float maxDepth;
};

struct Offset2D {
    int32_t x;
    int32_t y;
};

struct Extent2D {
    uint32_t width;
    uint32_t height;
};

struct Rect2D {
    Offset2D offset;
    Extent2D extent;
};

struct PipelineViewportStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineViewportStateCreateFlags flags;
    uint32_t viewportCount;
    const Viewport *pViewports;
    uint32_t scissorCount;
    const Rect2D *pScissors;
};

struct PipelineRasterizationStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineRasterizationStateCreateFlags flags;
    Bool depthClampEnable;
    Bool rasterizerDiscardEnable;
    PolygonMode polygonMode;
    CullMode cullMode;
    FrontFace frontFace;
    Bool depthBiasEnable;
    float depthBiasConstantFactor;
    float depthBiasClamp;
    float depthBiasSlopeFactor;
    float lineWidth;
};

struct PipelineMultisampleStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineMultisampleStateCreateFlags flags;
    SampleCount rasterizationSamples;
    Bool sampleShadingEnable;
    float minSampleShading;
    const SampleMask *pSampleMask;
    Bool alphaToCoverageEnable;
    Bool alphaToOneEnable;
};

struct StencilOpState {
    StencilOp failOp;
    StencilOp passOp;
    StencilOp depthFailOp;
    CompareOp compareOp;
    uint32_t compareMask;
    uint32_t writeMask;
    uint32_t reference;
};

struct PipelineDepthStencilStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineDepthStencilStateCreateFlags flags;
    Bool depthTestEnable;
    Bool depthWriteEnable;
    CompareOp depthCompareOp;
    Bool depthBoundsTestEnable;
    Bool stencilTestEnable;
    StencilOpState front;
    StencilOpState back;
    float minDepthBounds;
    float maxDepthBounds;
};

struct PipelineColorBlendAttachmentState {
    Bool blendEnable;
    BlendFactor srcColorBlendFactor;
    BlendFactor dstColorBlendFactor;
    BlendOp colorBlendOp;
    BlendFactor srcAlphaBlendFactor;
    BlendFactor dstAlphaBlendFactor;
    BlendOp alphaBlendOp;
    ColorComponent colorWriteMask;
};

struct PipelineColorBlendStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineColorBlendStateCreateFlags flags;
    Bool logicOpEnable;
    LogicOp logicOp;
    uint32_t attachmentCount;
    const PipelineColorBlendAttachmentState *pAttachments;
    float blendConstants [4];
};

struct PipelineDynamicStateCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineDynamicStateCreateFlags flags;
    uint32_t dynamicStateCount;
    const DynamicState *pDynamicStates;
};

struct GraphicsPipelineCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCreateFlags flags;
    uint32_t stageCount;
    const PipelineShaderStageCreateInfo *pStages;
    const PipelineVertexInputStateCreateInfo *pVertexInputState;
    const PipelineInputAssemblyStateCreateInfo *pInputAssemblyState;
    const PipelineTessellationStateCreateInfo *pTessellationState;
    const PipelineViewportStateCreateInfo *pViewportState;
    const PipelineRasterizationStateCreateInfo *pRasterizationState;
    const PipelineMultisampleStateCreateInfo *pMultisampleState;
    const PipelineDepthStencilStateCreateInfo *pDepthStencilState;
    const PipelineColorBlendStateCreateInfo *pColorBlendState;
    const PipelineDynamicStateCreateInfo *pDynamicState;
    PipelineLayout layout;
    RenderPass renderPass;
    uint32_t subpass;
    Pipeline basePipelineHandle;
    int32_t basePipelineIndex;
};

struct PushConstantRange {
    ShaderStage stageFlags;
    uint32_t offset;
    uint32_t size;
};

struct PipelineLayoutCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineLayoutCreateFlags flags;
    uint32_t setLayoutCount;
    const DescriptorSetLayout *pSetLayouts;
    uint32_t pushConstantRangeCount;
    const PushConstantRange *pPushConstantRanges;
};

struct SamplerCreateInfo {
    StructureType sType;
    const void *pNext;
    SamplerCreateFlags flags;
    Filter magFilter;
    Filter minFilter;
    SamplerMipmapMode mipmapMode;
    SamplerAddressMode addressModeU;
    SamplerAddressMode addressModeV;
    SamplerAddressMode addressModeW;
    float mipLodBias;
    Bool anisotropyEnable;
    float maxAnisotropy;
    Bool compareEnable;
    CompareOp compareOp;
    float minLod;
    float maxLod;
    BorderColor borderColor;
    Bool unnormalizedCoordinates;
};

struct CopyDescriptorSet {
    StructureType sType;
    const void *pNext;
    DescriptorSet srcSet;
    uint32_t srcBinding;
    uint32_t srcArrayElement;
    DescriptorSet dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
};

struct DescriptorPoolSize {
    DescriptorType type;
    uint32_t descriptorCount;
};

struct DescriptorPoolCreateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorPoolCreateFlags flags;
    uint32_t maxSets;
    uint32_t poolSizeCount;
    const DescriptorPoolSize *pPoolSizes;
};

struct DescriptorSetAllocateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorPool descriptorPool;
    uint32_t descriptorSetCount;
    const DescriptorSetLayout *pSetLayouts;
};

struct DescriptorSetLayoutBinding {
    uint32_t binding;
    DescriptorType descriptorType;
    uint32_t descriptorCount;
    ShaderStage stageFlags;
    const Sampler *pImmutableSamplers;
};

struct DescriptorSetLayoutCreateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorSetLayoutCreateFlags flags;
    uint32_t bindingCount;
    const DescriptorSetLayoutBinding *pBindings;
};

struct DescriptorImageInfo {
    Sampler sampler;
    ImageView imageView;
    ImageLayout imageLayout;
};

struct DescriptorBufferInfo {
    Buffer buffer;
    DeviceSize offset;
    DeviceSize range;
};

struct WriteDescriptorSet {
    StructureType sType;
    const void *pNext;
    DescriptorSet dstSet;
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    DescriptorType descriptorType;
    const DescriptorImageInfo *pImageInfo;
    const DescriptorBufferInfo *pBufferInfo;
    const BufferView *pTexelBufferView;
};

struct FramebufferCreateInfo {
    StructureType sType;
    const void *pNext;
    FramebufferCreateFlags flags;
    RenderPass renderPass;
    uint32_t attachmentCount;
    const ImageView *pAttachments;
    uint32_t width;
    uint32_t height;
    uint32_t layers;
};

struct AttachmentDescription {
    AttachmentDescriptionFlags flags;
    Format format;
    SampleCount samples;
    AttachmentLoadOp loadOp;
    AttachmentStoreOp storeOp;
    AttachmentLoadOp stencilLoadOp;
    AttachmentStoreOp stencilStoreOp;
    ImageLayout initialLayout;
    ImageLayout finalLayout;
};

struct AttachmentReference {
    uint32_t attachment;
    ImageLayout layout;
};

struct SubpassDescription {
    SubpassDescriptionFlags flags;
    PipelineBindPoint pipelineBindPoint;
    uint32_t inputAttachmentCount;
    const AttachmentReference *pInputAttachments;
    uint32_t colorAttachmentCount;
    const AttachmentReference *pColorAttachments;
    const AttachmentReference *pResolveAttachments;
    const AttachmentReference *pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    const uint32_t *pPreserveAttachments;
};

struct SubpassDependency {
    uint32_t srcSubpass;
    uint32_t dstSubpass;
    PipelineStage srcStageMask;
    PipelineStage dstStageMask;
    Access srcAccessMask;
    Access dstAccessMask;
    DependencyFlags dependencyFlags;
};

struct RenderPassCreateInfo {
    StructureType sType;
    const void *pNext;
    RenderPassCreateFlags flags;
    uint32_t attachmentCount;
    const AttachmentDescription *pAttachments;
    uint32_t subpassCount;
    const SubpassDescription *pSubpasses;
    uint32_t dependencyCount;
    const SubpassDependency *pDependencies;
};

struct CommandPoolCreateInfo {
    StructureType sType;
    const void *pNext;
    CommandPoolCreateFlags flags;
    uint32_t queueFamilyIndex;
};

struct CommandBufferAllocateInfo {
    StructureType sType;
    const void *pNext;
    CommandPool commandPool;
    CommandBufferLevel level;
    uint32_t commandBufferCount;
};

struct CommandBufferInheritanceInfo {
    StructureType sType;
    const void *pNext;
    RenderPass renderPass;
    uint32_t subpass;
    Framebuffer framebuffer;
    Bool occlusionQueryEnable;
    QueryControlFlags queryFlags;
    QueryPipelineStatisticFlags pipelineStatistics;
};

struct CommandBufferBeginInfo {
    StructureType sType;
    const void *pNext;
    CommandBufferUsage flags;
    const CommandBufferInheritanceInfo *pInheritanceInfo;
};

struct BufferCopy {
    DeviceSize srcOffset;
    DeviceSize dstOffset;
    DeviceSize size;
};

struct ImageSubresourceLayers {
    ImageAspect aspectMask;
    uint32_t mipLevel;
    uint32_t baseArrayLayer;
    uint32_t layerCount;
};

struct BufferImageCopy {
    DeviceSize bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    ImageSubresourceLayers imageSubresource;
    Offset3D imageOffset;
    Extent3D imageExtent;
};

union ClearColorValue {
    float float32 [4];
    int32_t int32 [4];
    uint32_t uint32 [4];
};

struct ClearDepthStencilValue {
    float depth;
    uint32_t stencil;
};

union ClearValue {
    ClearColorValue color;
    ClearDepthStencilValue depthStencil;
};

struct ClearAttachment {
    ImageAspect aspectMask;
    uint32_t colorAttachment;
    ClearValue clearValue;
};

struct ClearRect {
    Rect2D rect;
    uint32_t baseArrayLayer;
    uint32_t layerCount;
};

struct ImageBlit {
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffsets [2];
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffsets [2];
};

struct ImageCopy {
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffset;
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffset;
    Extent3D extent;
};

struct ImageResolve {
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffset;
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffset;
    Extent3D extent;
};

struct RenderPassBeginInfo {
    StructureType sType;
    const void *pNext;
    RenderPass renderPass;
    Framebuffer framebuffer;
    Rect2D renderArea;
    uint32_t clearValueCount;
    const ClearValue *pClearValues;
};

struct PhysicalDeviceSubgroupProperties {
    StructureType sType;
    void *pNext;
    uint32_t subgroupSize;
    ShaderStage supportedStages;
    SubgroupFeature supportedOperations;
    Bool quadOperationsInAllStages;
};

struct BindBufferMemoryInfo {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
    DeviceMemory memory;
    DeviceSize memoryOffset;
};

struct BindImageMemoryInfo {
    StructureType sType;
    const void *pNext;
    Image image;
    DeviceMemory memory;
    DeviceSize memoryOffset;
};

struct PhysicalDevice16BitStorageFeatures {
    StructureType sType;
    void *pNext;
    Bool storageBuffer16BitAccess;
    Bool uniformAndStorageBuffer16BitAccess;
    Bool storagePushConstant16;
    Bool storageInputOutput16;
};

struct MemoryDedicatedRequirements {
    StructureType sType;
    void *pNext;
    Bool prefersDedicatedAllocation;
    Bool requiresDedicatedAllocation;
};

struct MemoryDedicatedAllocateInfo {
    StructureType sType;
    const void *pNext;
    Image image;
    Buffer buffer;
};

struct MemoryAllocateFlagsInfo {
    StructureType sType;
    const void *pNext;
    MemoryAllocateFlags flags;
    uint32_t deviceMask;
};

struct DeviceGroupRenderPassBeginInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceMask;
    uint32_t deviceRenderAreaCount;
    const Rect2D *pDeviceRenderAreas;
};

struct DeviceGroupCommandBufferBeginInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceMask;
};

struct DeviceGroupSubmitInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const uint32_t *pWaitSemaphoreDeviceIndices;
    uint32_t commandBufferCount;
    const uint32_t *pCommandBufferDeviceMasks;
    uint32_t signalSemaphoreCount;
    const uint32_t *pSignalSemaphoreDeviceIndices;
};

struct DeviceGroupBindSparseInfo {
    StructureType sType;
    const void *pNext;
    uint32_t resourceDeviceIndex;
    uint32_t memoryDeviceIndex;
};

struct BindBufferMemoryDeviceGroupInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceIndexCount;
    const uint32_t *pDeviceIndices;
};

struct BindImageMemoryDeviceGroupInfo {
    StructureType sType;
    const void *pNext;
    uint32_t deviceIndexCount;
    const uint32_t *pDeviceIndices;
    uint32_t splitInstanceBindRegionCount;
    const Rect2D *pSplitInstanceBindRegions;
};

struct PhysicalDeviceGroupProperties {
    StructureType sType;
    void *pNext;
    uint32_t physicalDeviceCount;
    PhysicalDevice physicalDevices [k_max_device_group_size ];
    Bool subsetAllocation;
};

struct DeviceGroupDeviceCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t physicalDeviceCount;
    const PhysicalDevice *pPhysicalDevices;
};

struct BufferMemoryRequirementsInfo2 {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
};

struct ImageMemoryRequirementsInfo2 {
    StructureType sType;
    const void *pNext;
    Image image;
};

struct ImageSparseMemoryRequirementsInfo2 {
    StructureType sType;
    const void *pNext;
    Image image;
};

struct MemoryRequirements {
    DeviceSize size;
    DeviceSize alignment;
    uint32_t memoryTypeBits;
};

struct MemoryRequirements2 {
    StructureType sType;
    void *pNext;
    MemoryRequirements memoryRequirements;
};

struct SparseImageFormatProperties {
    ImageAspect aspectMask;
    Extent3D imageGranularity;
    SparseImageFormatFlags flags;
};

struct SparseImageMemoryRequirements {
    SparseImageFormatProperties formatProperties;
    uint32_t imageMipTailFirstLod;
    DeviceSize imageMipTailSize;
    DeviceSize imageMipTailOffset;
    DeviceSize imageMipTailStride;
};

struct SparseImageMemoryRequirements2 {
    StructureType sType;
    void *pNext;
    SparseImageMemoryRequirements memoryRequirements;
};

struct PhysicalDeviceFeatures2 {
    StructureType sType;
    void *pNext;
    PhysicalDeviceFeatures features;
};

struct PhysicalDeviceLimits {
    uint32_t maxImageDimension1D;
    uint32_t maxImageDimension2D;
    uint32_t maxImageDimension3D;
    uint32_t maxImageDimensionCube;
    uint32_t maxImageArrayLayers;
    uint32_t maxTexelBufferElements;
    uint32_t maxUniformBufferRange;
    uint32_t maxStorageBufferRange;
    uint32_t maxPushConstantsSize;
    uint32_t maxMemoryAllocationCount;
    uint32_t maxSamplerAllocationCount;
    DeviceSize bufferImageGranularity;
    DeviceSize sparseAddressSpaceSize;
    uint32_t maxBoundDescriptorSets;
    uint32_t maxPerStageDescriptorSamplers;
    uint32_t maxPerStageDescriptorUniformBuffers;
    uint32_t maxPerStageDescriptorStorageBuffers;
    uint32_t maxPerStageDescriptorSampledImages;
    uint32_t maxPerStageDescriptorStorageImages;
    uint32_t maxPerStageDescriptorInputAttachments;
    uint32_t maxPerStageResources;
    uint32_t maxDescriptorSetSamplers;
    uint32_t maxDescriptorSetUniformBuffers;
    uint32_t maxDescriptorSetUniformBuffersDynamic;
    uint32_t maxDescriptorSetStorageBuffers;
    uint32_t maxDescriptorSetStorageBuffersDynamic;
    uint32_t maxDescriptorSetSampledImages;
    uint32_t maxDescriptorSetStorageImages;
    uint32_t maxDescriptorSetInputAttachments;
    uint32_t maxVertexInputAttributes;
    uint32_t maxVertexInputBindings;
    uint32_t maxVertexInputAttributeOffset;
    uint32_t maxVertexInputBindingStride;
    uint32_t maxVertexOutputComponents;
    uint32_t maxTessellationGenerationLevel;
    uint32_t maxTessellationPatchSize;
    uint32_t maxTessellationControlPerVertexInputComponents;
    uint32_t maxTessellationControlPerVertexOutputComponents;
    uint32_t maxTessellationControlPerPatchOutputComponents;
    uint32_t maxTessellationControlTotalOutputComponents;
    uint32_t maxTessellationEvaluationInputComponents;
    uint32_t maxTessellationEvaluationOutputComponents;
    uint32_t maxGeometryShaderInvocations;
    uint32_t maxGeometryInputComponents;
    uint32_t maxGeometryOutputComponents;
    uint32_t maxGeometryOutputVertices;
    uint32_t maxGeometryTotalOutputComponents;
    uint32_t maxFragmentInputComponents;
    uint32_t maxFragmentOutputAttachments;
    uint32_t maxFragmentDualSrcAttachments;
    uint32_t maxFragmentCombinedOutputResources;
    uint32_t maxComputeSharedMemorySize;
    uint32_t maxComputeWorkGroupCount [3];
    uint32_t maxComputeWorkGroupInvocations;
    uint32_t maxComputeWorkGroupSize [3];
    uint32_t subPixelPrecisionBits;
    uint32_t subTexelPrecisionBits;
    uint32_t mipmapPrecisionBits;
    uint32_t maxDrawIndexedIndexValue;
    uint32_t maxDrawIndirectCount;
    float maxSamplerLodBias;
    float maxSamplerAnisotropy;
    uint32_t maxViewports;
    uint32_t maxViewportDimensions [2];
    float viewportBoundsRange [2];
    uint32_t viewportSubPixelBits;
    size_t minMemoryMapAlignment;
    DeviceSize minTexelBufferOffsetAlignment;
    DeviceSize minUniformBufferOffsetAlignment;
    DeviceSize minStorageBufferOffsetAlignment;
    int32_t minTexelOffset;
    uint32_t maxTexelOffset;
    int32_t minTexelGatherOffset;
    uint32_t maxTexelGatherOffset;
    float minInterpolationOffset;
    float maxInterpolationOffset;
    uint32_t subPixelInterpolationOffsetBits;
    uint32_t maxFramebufferWidth;
    uint32_t maxFramebufferHeight;
    uint32_t maxFramebufferLayers;
    SampleCount framebufferColorSampleCounts;
    SampleCount framebufferDepthSampleCounts;
    SampleCount framebufferStencilSampleCounts;
    SampleCount framebufferNoAttachmentsSampleCounts;
    uint32_t maxColorAttachments;
    SampleCount sampledImageColorSampleCounts;
    SampleCount sampledImageIntegerSampleCounts;
    SampleCount sampledImageDepthSampleCounts;
    SampleCount sampledImageStencilSampleCounts;
    SampleCount storageImageSampleCounts;
    uint32_t maxSampleMaskWords;
    Bool timestampComputeAndGraphics;
    float timestampPeriod;
    uint32_t maxClipDistances;
    uint32_t maxCullDistances;
    uint32_t maxCombinedClipAndCullDistances;
    uint32_t discreteQueuePriorities;
    float pointSizeRange [2];
    float lineWidthRange [2];
    float pointSizeGranularity;
    float lineWidthGranularity;
    Bool strictLines;
    Bool standardSampleLocations;
    DeviceSize optimalBufferCopyOffsetAlignment;
    DeviceSize optimalBufferCopyRowPitchAlignment;
    DeviceSize nonCoherentAtomSize;
};

struct PhysicalDeviceSparseProperties {
    Bool residencyStandard2DBlockShape;
    Bool residencyStandard2DMultisampleBlockShape;
    Bool residencyStandard3DBlockShape;
    Bool residencyAlignedMipSize;
    Bool residencyNonResidentStrict;
};

struct PhysicalDeviceProperties {
    uint32_t apiVersion;
    uint32_t driverVersion;
    uint32_t vendorID;
    uint32_t deviceID;
    PhysicalDeviceType deviceType;
    char deviceName [k_max_physical_device_name_size ];
    uint8_t pipelineCacheUUID [k_uuid_size ];
    PhysicalDeviceLimits limits;
    PhysicalDeviceSparseProperties sparseProperties;
};

struct PhysicalDeviceProperties2 {
    StructureType sType;
    void *pNext;
    PhysicalDeviceProperties properties;
};

struct FormatProperties {
    FormatFeature linearTilingFeatures;
    FormatFeature optimalTilingFeatures;
    FormatFeature bufferFeatures;
};

struct FormatProperties2 {
    StructureType sType;
    void *pNext;
    FormatProperties formatProperties;
};

struct ImageFormatProperties {
    Extent3D maxExtent;
    uint32_t maxMipLevels;
    uint32_t maxArrayLayers;
    SampleCount sampleCounts;
    DeviceSize maxResourceSize;
};

struct ImageFormatProperties2 {
    StructureType sType;
    void *pNext;
    ImageFormatProperties imageFormatProperties;
};

struct PhysicalDeviceImageFormatInfo2 {
    StructureType sType;
    const void *pNext;
    Format format;
    ImageType type;
    ImageTiling tiling;
    ImageUsage usage;
    ImageCreateFlags flags;
};

struct QueueFamilyProperties {
    QueueFlags queueFlags;
    uint32_t queueCount;
    uint32_t timestampValidBits;
    Extent3D minImageTransferGranularity;
};

struct QueueFamilyProperties2 {
    StructureType sType;
    void *pNext;
    QueueFamilyProperties queueFamilyProperties;
};

struct MemoryType {
    MemoryPropertyFlags propertyFlags;
    uint32_t heapIndex;
};

struct MemoryHeap {
    DeviceSize size;
    MemoryHeapFlags flags;
};

struct PhysicalDeviceMemoryProperties {
    uint32_t memoryTypeCount;
    MemoryType memoryTypes [k_max_memory_types ];
    uint32_t memoryHeapCount;
    MemoryHeap memoryHeaps [k_max_memory_heaps ];
};

struct PhysicalDeviceMemoryProperties2 {
    StructureType sType;
    void *pNext;
    PhysicalDeviceMemoryProperties memoryProperties;
};

struct SparseImageFormatProperties2 {
    StructureType sType;
    void *pNext;
    SparseImageFormatProperties properties;
};

struct PhysicalDeviceSparseImageFormatInfo2 {
    StructureType sType;
    const void *pNext;
    Format format;
    ImageType type;
    SampleCount samples;
    ImageUsage usage;
    ImageTiling tiling;
};

struct PhysicalDevicePointClippingProperties {
    StructureType sType;
    void *pNext;
    PointClippingBehavior pointClippingBehavior;
};

struct InputAttachmentAspectReference {
    uint32_t subpass;
    uint32_t inputAttachmentIndex;
    ImageAspect aspectMask;
};

struct RenderPassInputAttachmentAspectCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t aspectReferenceCount;
    const InputAttachmentAspectReference *pAspectReferences;
};

struct ImageViewUsageCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageUsage usage;
};

struct PipelineTessellationDomainOriginStateCreateInfo {
    StructureType sType;
    const void *pNext;
    TessellationDomainOrigin domainOrigin;
};

struct RenderPassMultiviewCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t subpassCount;
    const uint32_t *pViewMasks;
    uint32_t dependencyCount;
    const int32_t *pViewOffsets;
    uint32_t correlationMaskCount;
    const uint32_t *pCorrelationMasks;
};

struct PhysicalDeviceMultiviewFeatures {
    StructureType sType;
    void *pNext;
    Bool multiview;
    Bool multiviewGeometryShader;
    Bool multiviewTessellationShader;
};

struct PhysicalDeviceMultiviewProperties {
    StructureType sType;
    void *pNext;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
};

struct PhysicalDeviceVariablePointersFeatures {
    StructureType sType;
    void *pNext;
    Bool variablePointersStorageBuffer;
    Bool variablePointers;
};

struct PhysicalDeviceProtectedMemoryFeatures {
    StructureType sType;
    void *pNext;
    Bool protectedMemory;
};

struct PhysicalDeviceProtectedMemoryProperties {
    StructureType sType;
    void *pNext;
    Bool protectedNoFault;
};

struct DeviceQueueInfo2 {
    StructureType sType;
    const void *pNext;
    DeviceQueueCreateFlags flags;
    uint32_t queueFamilyIndex;
    uint32_t queueIndex;
};

struct ProtectedSubmitInfo {
    StructureType sType;
    const void *pNext;
    Bool protectedSubmit;
};

struct SamplerYcbcrConversionCreateInfo {
    StructureType sType;
    const void *pNext;
    Format format;
    SamplerYcbcrModelConversion ycbcrModel;
    SamplerYcbcrRange ycbcrRange;
    ComponentMapping components;
    ChromaLocation xChromaOffset;
    ChromaLocation yChromaOffset;
    Filter chromaFilter;
    Bool forceExplicitReconstruction;
};

struct SamplerYcbcrConversionInfo {
    StructureType sType;
    const void *pNext;
    SamplerYcbcrConversion conversion;
};

struct BindImagePlaneMemoryInfo {
    StructureType sType;
    const void *pNext;
    ImageAspect planeAspect;
};

struct ImagePlaneMemoryRequirementsInfo {
    StructureType sType;
    const void *pNext;
    ImageAspect planeAspect;
};

struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    StructureType sType;
    void *pNext;
    Bool samplerYcbcrConversion;
};

struct SamplerYcbcrConversionImageFormatProperties {
    StructureType sType;
    void *pNext;
    uint32_t combinedImageSamplerDescriptorCount;
};

struct DescriptorUpdateTemplateEntry {
    uint32_t dstBinding;
    uint32_t dstArrayElement;
    uint32_t descriptorCount;
    DescriptorType descriptorType;
    size_t offset;
    size_t stride;
};

struct DescriptorUpdateTemplateCreateInfo {
    StructureType sType;
    const void *pNext;
    DescriptorUpdateTemplateCreateFlags flags;
    uint32_t descriptorUpdateEntryCount;
    const DescriptorUpdateTemplateEntry *pDescriptorUpdateEntries;
    DescriptorUpdateTemplateType templateType;
    DescriptorSetLayout descriptorSetLayout;
    PipelineBindPoint pipelineBindPoint;
    PipelineLayout pipelineLayout;
    uint32_t set;
};

struct PhysicalDeviceExternalImageFormatInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleType;
};

struct ExternalMemoryProperties {
    ExternalMemoryFeature externalMemoryFeatures;
    ExternalMemoryHandleTypeFlags exportFromImportedHandleTypes;
    ExternalMemoryHandleTypeFlags compatibleHandleTypes;
};

struct ExternalImageFormatProperties {
    StructureType sType;
    void *pNext;
    ExternalMemoryProperties externalMemoryProperties;
};

struct PhysicalDeviceExternalBufferInfo {
    StructureType sType;
    const void *pNext;
    BufferCreateFlags flags;
    BufferUsage usage;
    ExternalMemoryHandleTypeFlags handleType;
};

struct ExternalBufferProperties {
    StructureType sType;
    void *pNext;
    ExternalMemoryProperties externalMemoryProperties;
};

struct PhysicalDeviceIDProperties {
    StructureType sType;
    void *pNext;
    uint8_t deviceUUID [k_uuid_size ];
    uint8_t driverUUID [k_uuid_size ];
    uint8_t deviceLUID [k_luid_size ];
    uint32_t deviceNodeMask;
    Bool deviceLUIDValid;
};

struct ExternalMemoryImageCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleTypes;
};

struct ExternalMemoryBufferCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleTypes;
};

struct ExportMemoryAllocateInfo {
    StructureType sType;
    const void *pNext;
    ExternalMemoryHandleTypeFlags handleTypes;
};

struct PhysicalDeviceExternalFenceInfo {
    StructureType sType;
    const void *pNext;
    ExternalFenceHandleTypeFlags handleType;
};

struct ExternalFenceProperties {
    StructureType sType;
    void *pNext;
    ExternalFenceHandleTypeFlags exportFromImportedHandleTypes;
    ExternalFenceHandleTypeFlags compatibleHandleTypes;
    ExternalFenceFeature externalFenceFeatures;
};

struct ExportFenceCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalFenceHandleTypeFlags handleTypes;
};

struct ExportSemaphoreCreateInfo {
    StructureType sType;
    const void *pNext;
    ExternalSemaphoreHandleTypeFlags handleTypes;
};

struct PhysicalDeviceExternalSemaphoreInfo {
    StructureType sType;
    const void *pNext;
    ExternalSemaphoreHandleTypeFlags handleType;
};

struct ExternalSemaphoreProperties {
    StructureType sType;
    void *pNext;
    ExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes;
    ExternalSemaphoreHandleTypeFlags compatibleHandleTypes;
    ExternalSemaphoreFeature externalSemaphoreFeatures;
};

struct PhysicalDeviceMaintenance3Properties {
    StructureType sType;
    void *pNext;
    uint32_t maxPerSetDescriptors;
    DeviceSize maxMemoryAllocationSize;
};

struct DescriptorSetLayoutSupport {
    StructureType sType;
    void *pNext;
    Bool supported;
};

struct PhysicalDeviceShaderDrawParametersFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderDrawParameters;
};

struct PhysicalDeviceVulkan11Features {
    StructureType sType;
    void *pNext;
    Bool storageBuffer16BitAccess;
    Bool uniformAndStorageBuffer16BitAccess;
    Bool storagePushConstant16;
    Bool storageInputOutput16;
    Bool multiview;
    Bool multiviewGeometryShader;
    Bool multiviewTessellationShader;
    Bool variablePointersStorageBuffer;
    Bool variablePointers;
    Bool protectedMemory;
    Bool samplerYcbcrConversion;
    Bool shaderDrawParameters;
};

struct PhysicalDeviceVulkan11Properties {
    StructureType sType;
    void *pNext;
    uint8_t deviceUUID [k_uuid_size ];
    uint8_t driverUUID [k_uuid_size ];
    uint8_t deviceLUID [k_luid_size ];
    uint32_t deviceNodeMask;
    Bool deviceLUIDValid;
    uint32_t subgroupSize;
    ShaderStage subgroupSupportedStages;
    SubgroupFeature subgroupSupportedOperations;
    Bool subgroupQuadOperationsInAllStages;
    PointClippingBehavior pointClippingBehavior;
    uint32_t maxMultiviewViewCount;
    uint32_t maxMultiviewInstanceIndex;
    Bool protectedNoFault;
    uint32_t maxPerSetDescriptors;
    DeviceSize maxMemoryAllocationSize;
};

struct PhysicalDeviceVulkan12Features {
    StructureType sType;
    void *pNext;
    Bool samplerMirrorClampToEdge;
    Bool drawIndirectCount;
    Bool storageBuffer8BitAccess;
    Bool uniformAndStorageBuffer8BitAccess;
    Bool storagePushConstant8;
    Bool shaderBufferInt64Atomics;
    Bool shaderSharedInt64Atomics;
    Bool shaderFloat16;
    Bool shaderInt8;
    Bool descriptorIndexing;
    Bool shaderInputAttachmentArrayDynamicIndexing;
    Bool shaderUniformTexelBufferArrayDynamicIndexing;
    Bool shaderStorageTexelBufferArrayDynamicIndexing;
    Bool shaderUniformBufferArrayNonUniformIndexing;
    Bool shaderSampledImageArrayNonUniformIndexing;
    Bool shaderStorageBufferArrayNonUniformIndexing;
    Bool shaderStorageImageArrayNonUniformIndexing;
    Bool shaderInputAttachmentArrayNonUniformIndexing;
    Bool shaderUniformTexelBufferArrayNonUniformIndexing;
    Bool shaderStorageTexelBufferArrayNonUniformIndexing;
    Bool descriptorBindingUniformBufferUpdateAfterBind;
    Bool descriptorBindingSampledImageUpdateAfterBind;
    Bool descriptorBindingStorageImageUpdateAfterBind;
    Bool descriptorBindingStorageBufferUpdateAfterBind;
    Bool descriptorBindingUniformTexelBufferUpdateAfterBind;
    Bool descriptorBindingStorageTexelBufferUpdateAfterBind;
    Bool descriptorBindingUpdateUnusedWhilePending;
    Bool descriptorBindingPartiallyBound;
    Bool descriptorBindingVariableDescriptorCount;
    Bool runtimeDescriptorArray;
    Bool samplerFilterMinmax;
    Bool scalarBlockLayout;
    Bool imagelessFramebuffer;
    Bool uniformBufferStandardLayout;
    Bool shaderSubgroupExtendedTypes;
    Bool separateDepthStencilLayouts;
    Bool hostQueryReset;
    Bool timelineSemaphore;
    Bool bufferDeviceAddress;
    Bool bufferDeviceAddressCaptureReplay;
    Bool bufferDeviceAddressMultiDevice;
    Bool vulkanMemoryModel;
    Bool vulkanMemoryModelDeviceScope;
    Bool vulkanMemoryModelAvailabilityVisibilityChains;
    Bool shaderOutputViewportIndex;
    Bool shaderOutputLayer;
    Bool subgroupBroadcastDynamicId;
};

struct ConformanceVersion {
    uint8_t major;
    uint8_t minor;
    uint8_t subminor;
    uint8_t patch;
};

struct PhysicalDeviceVulkan12Properties {
    StructureType sType;
    void *pNext;
    DriverId driverID;
    char driverName [k_max_driver_name_size ];
    char driverInfo [k_max_driver_info_size ];
    ConformanceVersion conformanceVersion;
    ShaderFloatControlsIndependence denormBehaviorIndependence;
    ShaderFloatControlsIndependence roundingModeIndependence;
    Bool shaderSignedZeroInfNanPreserveFloat16;
    Bool shaderSignedZeroInfNanPreserveFloat32;
    Bool shaderSignedZeroInfNanPreserveFloat64;
    Bool shaderDenormPreserveFloat16;
    Bool shaderDenormPreserveFloat32;
    Bool shaderDenormPreserveFloat64;
    Bool shaderDenormFlushToZeroFloat16;
    Bool shaderDenormFlushToZeroFloat32;
    Bool shaderDenormFlushToZeroFloat64;
    Bool shaderRoundingModeRTEFloat16;
    Bool shaderRoundingModeRTEFloat32;
    Bool shaderRoundingModeRTEFloat64;
    Bool shaderRoundingModeRTZFloat16;
    Bool shaderRoundingModeRTZFloat32;
    Bool shaderRoundingModeRTZFloat64;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    Bool shaderUniformBufferArrayNonUniformIndexingNative;
    Bool shaderSampledImageArrayNonUniformIndexingNative;
    Bool shaderStorageBufferArrayNonUniformIndexingNative;
    Bool shaderStorageImageArrayNonUniformIndexingNative;
    Bool shaderInputAttachmentArrayNonUniformIndexingNative;
    Bool robustBufferAccessUpdateAfterBind;
    Bool quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
    ResolveMode supportedDepthResolveModes;
    ResolveMode supportedStencilResolveModes;
    Bool independentResolveNone;
    Bool independentResolve;
    Bool filterMinmaxSingleComponentFormats;
    Bool filterMinmaxImageComponentMapping;
    uint64_t maxTimelineSemaphoreValueDifference;
    SampleCount framebufferIntegerColorSampleCounts;
};

struct ImageFormatListCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t viewFormatCount;
    const Format *pViewFormats;
};

struct AttachmentDescription2 {
    StructureType sType;
    const void *pNext;
    AttachmentDescriptionFlags flags;
    Format format;
    SampleCount samples;
    AttachmentLoadOp loadOp;
    AttachmentStoreOp storeOp;
    AttachmentLoadOp stencilLoadOp;
    AttachmentStoreOp stencilStoreOp;
    ImageLayout initialLayout;
    ImageLayout finalLayout;
};

struct AttachmentReference2 {
    StructureType sType;
    const void *pNext;
    uint32_t attachment;
    ImageLayout layout;
    ImageAspect aspectMask;
};

struct SubpassDescription2 {
    StructureType sType;
    const void *pNext;
    SubpassDescriptionFlags flags;
    PipelineBindPoint pipelineBindPoint;
    uint32_t viewMask;
    uint32_t inputAttachmentCount;
    const AttachmentReference2 *pInputAttachments;
    uint32_t colorAttachmentCount;
    const AttachmentReference2 *pColorAttachments;
    const AttachmentReference2 *pResolveAttachments;
    const AttachmentReference2 *pDepthStencilAttachment;
    uint32_t preserveAttachmentCount;
    const uint32_t *pPreserveAttachments;
};

struct SubpassDependency2 {
    StructureType sType;
    const void *pNext;
    uint32_t srcSubpass;
    uint32_t dstSubpass;
    PipelineStage srcStageMask;
    PipelineStage dstStageMask;
    Access srcAccessMask;
    Access dstAccessMask;
    DependencyFlags dependencyFlags;
    int32_t viewOffset;
};

struct RenderPassCreateInfo2 {
    StructureType sType;
    const void *pNext;
    RenderPassCreateFlags flags;
    uint32_t attachmentCount;
    const AttachmentDescription2 *pAttachments;
    uint32_t subpassCount;
    const SubpassDescription2 *pSubpasses;
    uint32_t dependencyCount;
    const SubpassDependency2 *pDependencies;
    uint32_t correlatedViewMaskCount;
    const uint32_t *pCorrelatedViewMasks;
};

struct SubpassBeginInfo {
    StructureType sType;
    const void *pNext;
    SubpassContents contents;
};

struct SubpassEndInfo {
    StructureType sType;
    const void *pNext;
};

struct PhysicalDevice8BitStorageFeatures {
    StructureType sType;
    void *pNext;
    Bool storageBuffer8BitAccess;
    Bool uniformAndStorageBuffer8BitAccess;
    Bool storagePushConstant8;
};

struct PhysicalDeviceDriverProperties {
    StructureType sType;
    void *pNext;
    DriverId driverID;
    char driverName [k_max_driver_name_size ];
    char driverInfo [k_max_driver_info_size ];
    ConformanceVersion conformanceVersion;
};

struct PhysicalDeviceShaderAtomicInt64Features {
    StructureType sType;
    void *pNext;
    Bool shaderBufferInt64Atomics;
    Bool shaderSharedInt64Atomics;
};

struct PhysicalDeviceShaderFloat16Int8Features {
    StructureType sType;
    void *pNext;
    Bool shaderFloat16;
    Bool shaderInt8;
};

struct PhysicalDeviceFloatControlsProperties {
    StructureType sType;
    void *pNext;
    ShaderFloatControlsIndependence denormBehaviorIndependence;
    ShaderFloatControlsIndependence roundingModeIndependence;
    Bool shaderSignedZeroInfNanPreserveFloat16;
    Bool shaderSignedZeroInfNanPreserveFloat32;
    Bool shaderSignedZeroInfNanPreserveFloat64;
    Bool shaderDenormPreserveFloat16;
    Bool shaderDenormPreserveFloat32;
    Bool shaderDenormPreserveFloat64;
    Bool shaderDenormFlushToZeroFloat16;
    Bool shaderDenormFlushToZeroFloat32;
    Bool shaderDenormFlushToZeroFloat64;
    Bool shaderRoundingModeRTEFloat16;
    Bool shaderRoundingModeRTEFloat32;
    Bool shaderRoundingModeRTEFloat64;
    Bool shaderRoundingModeRTZFloat16;
    Bool shaderRoundingModeRTZFloat32;
    Bool shaderRoundingModeRTZFloat64;
};

struct DescriptorSetLayoutBindingFlagsCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t bindingCount;
    const DescriptorBindingFlags *pBindingFlags;
};

struct PhysicalDeviceDescriptorIndexingFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderInputAttachmentArrayDynamicIndexing;
    Bool shaderUniformTexelBufferArrayDynamicIndexing;
    Bool shaderStorageTexelBufferArrayDynamicIndexing;
    Bool shaderUniformBufferArrayNonUniformIndexing;
    Bool shaderSampledImageArrayNonUniformIndexing;
    Bool shaderStorageBufferArrayNonUniformIndexing;
    Bool shaderStorageImageArrayNonUniformIndexing;
    Bool shaderInputAttachmentArrayNonUniformIndexing;
    Bool shaderUniformTexelBufferArrayNonUniformIndexing;
    Bool shaderStorageTexelBufferArrayNonUniformIndexing;
    Bool descriptorBindingUniformBufferUpdateAfterBind;
    Bool descriptorBindingSampledImageUpdateAfterBind;
    Bool descriptorBindingStorageImageUpdateAfterBind;
    Bool descriptorBindingStorageBufferUpdateAfterBind;
    Bool descriptorBindingUniformTexelBufferUpdateAfterBind;
    Bool descriptorBindingStorageTexelBufferUpdateAfterBind;
    Bool descriptorBindingUpdateUnusedWhilePending;
    Bool descriptorBindingPartiallyBound;
    Bool descriptorBindingVariableDescriptorCount;
    Bool runtimeDescriptorArray;
};

struct PhysicalDeviceDescriptorIndexingProperties {
    StructureType sType;
    void *pNext;
    uint32_t maxUpdateAfterBindDescriptorsInAllPools;
    Bool shaderUniformBufferArrayNonUniformIndexingNative;
    Bool shaderSampledImageArrayNonUniformIndexingNative;
    Bool shaderStorageBufferArrayNonUniformIndexingNative;
    Bool shaderStorageImageArrayNonUniformIndexingNative;
    Bool shaderInputAttachmentArrayNonUniformIndexingNative;
    Bool robustBufferAccessUpdateAfterBind;
    Bool quadDivergentImplicitLod;
    uint32_t maxPerStageDescriptorUpdateAfterBindSamplers;
    uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers;
    uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages;
    uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments;
    uint32_t maxPerStageUpdateAfterBindResources;
    uint32_t maxDescriptorSetUpdateAfterBindSamplers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers;
    uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
    uint32_t maxDescriptorSetUpdateAfterBindSampledImages;
    uint32_t maxDescriptorSetUpdateAfterBindStorageImages;
    uint32_t maxDescriptorSetUpdateAfterBindInputAttachments;
};

struct DescriptorSetVariableDescriptorCountAllocateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t descriptorSetCount;
    const uint32_t *pDescriptorCounts;
};

struct DescriptorSetVariableDescriptorCountLayoutSupport {
    StructureType sType;
    void *pNext;
    uint32_t maxVariableDescriptorCount;
};

struct SubpassDescriptionDepthStencilResolve {
    StructureType sType;
    const void *pNext;
    ResolveMode depthResolveMode;
    ResolveMode stencilResolveMode;
    const AttachmentReference2 *pDepthStencilResolveAttachment;
};

struct PhysicalDeviceDepthStencilResolveProperties {
    StructureType sType;
    void *pNext;
    ResolveMode supportedDepthResolveModes;
    ResolveMode supportedStencilResolveModes;
    Bool independentResolveNone;
    Bool independentResolve;
};

struct PhysicalDeviceScalarBlockLayoutFeatures {
    StructureType sType;
    void *pNext;
    Bool scalarBlockLayout;
};

struct ImageStencilUsageCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageUsage stencilUsage;
};

struct SamplerReductionModeCreateInfo {
    StructureType sType;
    const void *pNext;
    SamplerReductionMode reductionMode;
};

struct PhysicalDeviceSamplerFilterMinmaxProperties {
    StructureType sType;
    void *pNext;
    Bool filterMinmaxSingleComponentFormats;
    Bool filterMinmaxImageComponentMapping;
};

struct PhysicalDeviceVulkanMemoryModelFeatures {
    StructureType sType;
    void *pNext;
    Bool vulkanMemoryModel;
    Bool vulkanMemoryModelDeviceScope;
    Bool vulkanMemoryModelAvailabilityVisibilityChains;
};

struct PhysicalDeviceImagelessFramebufferFeatures {
    StructureType sType;
    void *pNext;
    Bool imagelessFramebuffer;
};

struct FramebufferAttachmentImageInfo {
    StructureType sType;
    const void *pNext;
    ImageCreateFlags flags;
    ImageUsage usage;
    uint32_t width;
    uint32_t height;
    uint32_t layerCount;
    uint32_t viewFormatCount;
    const Format *pViewFormats;
};

struct FramebufferAttachmentsCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t attachmentImageInfoCount;
    const FramebufferAttachmentImageInfo *pAttachmentImageInfos;
};

struct RenderPassAttachmentBeginInfo {
    StructureType sType;
    const void *pNext;
    uint32_t attachmentCount;
    const ImageView *pAttachments;
};

struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    StructureType sType;
    void *pNext;
    Bool uniformBufferStandardLayout;
};

struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderSubgroupExtendedTypes;
};

struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    StructureType sType;
    void *pNext;
    Bool separateDepthStencilLayouts;
};

struct AttachmentReferenceStencilLayout {
    StructureType sType;
    void *pNext;
    ImageLayout stencilLayout;
};

struct AttachmentDescriptionStencilLayout {
    StructureType sType;
    void *pNext;
    ImageLayout stencilInitialLayout;
    ImageLayout stencilFinalLayout;
};

struct PhysicalDeviceHostQueryResetFeatures {
    StructureType sType;
    void *pNext;
    Bool hostQueryReset;
};

struct PhysicalDeviceTimelineSemaphoreFeatures {
    StructureType sType;
    void *pNext;
    Bool timelineSemaphore;
};

struct PhysicalDeviceTimelineSemaphoreProperties {
    StructureType sType;
    void *pNext;
    uint64_t maxTimelineSemaphoreValueDifference;
};

struct SemaphoreTypeCreateInfo {
    StructureType sType;
    const void *pNext;
    SemaphoreType semaphoreType;
    uint64_t initialValue;
};

struct TimelineSemaphoreSubmitInfo {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreValueCount;
    const uint64_t *pWaitSemaphoreValues;
    uint32_t signalSemaphoreValueCount;
    const uint64_t *pSignalSemaphoreValues;
};

struct SemaphoreWaitInfo {
    StructureType sType;
    const void *pNext;
    SemaphoreWaitFlags flags;
    uint32_t semaphoreCount;
    const Semaphore *pSemaphores;
    const uint64_t *pValues;
};

struct SemaphoreSignalInfo {
    StructureType sType;
    const void *pNext;
    Semaphore semaphore;
    uint64_t value;
};

struct PhysicalDeviceBufferDeviceAddressFeatures {
    StructureType sType;
    void *pNext;
    Bool bufferDeviceAddress;
    Bool bufferDeviceAddressCaptureReplay;
    Bool bufferDeviceAddressMultiDevice;
};

struct BufferDeviceAddressInfo {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
};

struct BufferOpaqueCaptureAddressCreateInfo {
    StructureType sType;
    const void *pNext;
    uint64_t opaqueCaptureAddress;
};

struct MemoryOpaqueCaptureAddressAllocateInfo {
    StructureType sType;
    const void *pNext;
    uint64_t opaqueCaptureAddress;
};

struct DeviceMemoryOpaqueCaptureAddressInfo {
    StructureType sType;
    const void *pNext;
    DeviceMemory memory;
};

struct PhysicalDeviceVulkan13Features {
    StructureType sType;
    void *pNext;
    Bool robustImageAccess;
    Bool inlineUniformBlock;
    Bool descriptorBindingInlineUniformBlockUpdateAfterBind;
    Bool pipelineCreationCacheControl;
    Bool privateData;
    Bool shaderDemoteToHelperInvocation;
    Bool shaderTerminateInvocation;
    Bool subgroupSizeControl;
    Bool computeFullSubgroups;
    Bool synchronization2;
    Bool textureCompressionASTC_HDR;
    Bool shaderZeroInitializeWorkgroupMemory;
    Bool dynamicRendering;
    Bool shaderIntegerDotProduct;
    Bool maintenance4;
};

struct PhysicalDeviceVulkan13Properties {
    StructureType sType;
    void *pNext;
    uint32_t minSubgroupSize;
    uint32_t maxSubgroupSize;
    uint32_t maxComputeWorkgroupSubgroups;
    ShaderStage requiredSubgroupSizeStages;
    uint32_t maxInlineUniformBlockSize;
    uint32_t maxPerStageDescriptorInlineUniformBlocks;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t maxDescriptorSetInlineUniformBlocks;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    uint32_t maxInlineUniformTotalSize;
    Bool integerDotProduct8BitUnsignedAccelerated;
    Bool integerDotProduct8BitSignedAccelerated;
    Bool integerDotProduct8BitMixedSignednessAccelerated;
    Bool integerDotProduct4x8BitPackedUnsignedAccelerated;
    Bool integerDotProduct4x8BitPackedSignedAccelerated;
    Bool integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    Bool integerDotProduct16BitUnsignedAccelerated;
    Bool integerDotProduct16BitSignedAccelerated;
    Bool integerDotProduct16BitMixedSignednessAccelerated;
    Bool integerDotProduct32BitUnsignedAccelerated;
    Bool integerDotProduct32BitSignedAccelerated;
    Bool integerDotProduct32BitMixedSignednessAccelerated;
    Bool integerDotProduct64BitUnsignedAccelerated;
    Bool integerDotProduct64BitSignedAccelerated;
    Bool integerDotProduct64BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    DeviceSize storageTexelBufferOffsetAlignmentBytes;
    Bool storageTexelBufferOffsetSingleTexelAlignment;
    DeviceSize uniformTexelBufferOffsetAlignmentBytes;
    Bool uniformTexelBufferOffsetSingleTexelAlignment;
    DeviceSize maxBufferSize;
};

struct PipelineCreationFeedback {
    PipelineCreationFeedbackFlags flags;
    uint64_t duration;
};

struct PipelineCreationFeedbackCreateInfo {
    StructureType sType;
    const void *pNext;
    PipelineCreationFeedback *pPipelineCreationFeedback;
    uint32_t pipelineStageCreationFeedbackCount;
    PipelineCreationFeedback *pPipelineStageCreationFeedbacks;
};

struct PhysicalDeviceShaderTerminateInvocationFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderTerminateInvocation;
};

struct PhysicalDeviceToolProperties {
    StructureType sType;
    void *pNext;
    char name [k_max_extension_name_size ];
    char version [k_max_extension_name_size ];
    ToolPurposeFlags purposes;
    char description [k_max_description_size ];
    char layer [k_max_extension_name_size ];
};

struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderDemoteToHelperInvocation;
};

struct PhysicalDevicePrivateDataFeatures {
    StructureType sType;
    void *pNext;
    Bool privateData;
};

struct DevicePrivateDataCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t privateDataSlotRequestCount;
};

struct PrivateDataSlotCreateInfo {
    StructureType sType;
    const void *pNext;
    PrivateDataSlotCreateFlags flags;
};

struct PhysicalDevicePipelineCreationCacheControlFeatures {
    StructureType sType;
    void *pNext;
    Bool pipelineCreationCacheControl;
};

struct MemoryBarrier2 {
    StructureType sType;
    const void *pNext;
    PipelineStage2 srcStageMask;
    Access2 srcAccessMask;
    PipelineStage2 dstStageMask;
    Access2 dstAccessMask;
};

struct BufferMemoryBarrier2 {
    StructureType sType;
    const void *pNext;
    PipelineStage2 srcStageMask;
    Access2 srcAccessMask;
    PipelineStage2 dstStageMask;
    Access2 dstAccessMask;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    Buffer buffer;
    DeviceSize offset;
    DeviceSize size;
};

struct ImageMemoryBarrier2 {
    StructureType sType;
    const void *pNext;
    PipelineStage2 srcStageMask;
    Access2 srcAccessMask;
    PipelineStage2 dstStageMask;
    Access2 dstAccessMask;
    ImageLayout oldLayout;
    ImageLayout newLayout;
    uint32_t srcQueueFamilyIndex;
    uint32_t dstQueueFamilyIndex;
    Image image;
    ImageSubresourceRange subresourceRange;
};

struct DependencyInfo {
    StructureType sType;
    const void *pNext;
    DependencyFlags dependencyFlags;
    uint32_t memoryBarrierCount;
    const MemoryBarrier2 *pMemoryBarriers;
    uint32_t bufferMemoryBarrierCount;
    const BufferMemoryBarrier2 *pBufferMemoryBarriers;
    uint32_t imageMemoryBarrierCount;
    const ImageMemoryBarrier2 *pImageMemoryBarriers;
};

struct SemaphoreSubmitInfo {
    StructureType sType;
    const void *pNext;
    Semaphore semaphore;
    uint64_t value;
    PipelineStage2 stageMask;
    uint32_t deviceIndex;
};

struct CommandBufferSubmitInfo {
    StructureType sType;
    const void *pNext;
    CommandBuffer commandBuffer;
    uint32_t deviceMask;
};

struct SubmitInfo2 {
    StructureType sType;
    const void *pNext;
    SubmitFlags flags;
    uint32_t waitSemaphoreInfoCount;
    const SemaphoreSubmitInfo *pWaitSemaphoreInfos;
    uint32_t commandBufferInfoCount;
    const CommandBufferSubmitInfo *pCommandBufferInfos;
    uint32_t signalSemaphoreInfoCount;
    const SemaphoreSubmitInfo *pSignalSemaphoreInfos;
};

struct PhysicalDeviceSynchronization2Features {
    StructureType sType;
    void *pNext;
    Bool synchronization2;
};

struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderZeroInitializeWorkgroupMemory;
};

struct PhysicalDeviceImageRobustnessFeatures {
    StructureType sType;
    void *pNext;
    Bool robustImageAccess;
};

struct BufferCopy2 {
    StructureType sType;
    const void *pNext;
    DeviceSize srcOffset;
    DeviceSize dstOffset;
    DeviceSize size;
};

struct CopyBufferInfo2 {
    StructureType sType;
    const void *pNext;
    Buffer srcBuffer;
    Buffer dstBuffer;
    uint32_t regionCount;
    const BufferCopy2 *pRegions;
};

struct ImageCopy2 {
    StructureType sType;
    const void *pNext;
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffset;
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffset;
    Extent3D extent;
};

struct CopyImageInfo2 {
    StructureType sType;
    const void *pNext;
    Image srcImage;
    ImageLayout srcImageLayout;
    Image dstImage;
    ImageLayout dstImageLayout;
    uint32_t regionCount;
    const ImageCopy2 *pRegions;
};

struct BufferImageCopy2 {
    StructureType sType;
    const void *pNext;
    DeviceSize bufferOffset;
    uint32_t bufferRowLength;
    uint32_t bufferImageHeight;
    ImageSubresourceLayers imageSubresource;
    Offset3D imageOffset;
    Extent3D imageExtent;
};

struct CopyBufferToImageInfo2 {
    StructureType sType;
    const void *pNext;
    Buffer srcBuffer;
    Image dstImage;
    ImageLayout dstImageLayout;
    uint32_t regionCount;
    const BufferImageCopy2 *pRegions;
};

struct CopyImageToBufferInfo2 {
    StructureType sType;
    const void *pNext;
    Image srcImage;
    ImageLayout srcImageLayout;
    Buffer dstBuffer;
    uint32_t regionCount;
    const BufferImageCopy2 *pRegions;
};

struct ImageBlit2 {
    StructureType sType;
    const void *pNext;
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffsets [2];
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffsets [2];
};

struct BlitImageInfo2 {
    StructureType sType;
    const void *pNext;
    Image srcImage;
    ImageLayout srcImageLayout;
    Image dstImage;
    ImageLayout dstImageLayout;
    uint32_t regionCount;
    const ImageBlit2 *pRegions;
    Filter filter;
};

struct ImageResolve2 {
    StructureType sType;
    const void *pNext;
    ImageSubresourceLayers srcSubresource;
    Offset3D srcOffset;
    ImageSubresourceLayers dstSubresource;
    Offset3D dstOffset;
    Extent3D extent;
};

struct ResolveImageInfo2 {
    StructureType sType;
    const void *pNext;
    Image srcImage;
    ImageLayout srcImageLayout;
    Image dstImage;
    ImageLayout dstImageLayout;
    uint32_t regionCount;
    const ImageResolve2 *pRegions;
};

struct PhysicalDeviceSubgroupSizeControlFeatures {
    StructureType sType;
    void *pNext;
    Bool subgroupSizeControl;
    Bool computeFullSubgroups;
};

struct PhysicalDeviceSubgroupSizeControlProperties {
    StructureType sType;
    void *pNext;
    uint32_t minSubgroupSize;
    uint32_t maxSubgroupSize;
    uint32_t maxComputeWorkgroupSubgroups;
    ShaderStage requiredSubgroupSizeStages;
};

struct PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    StructureType sType;
    void *pNext;
    uint32_t requiredSubgroupSize;
};

struct PhysicalDeviceInlineUniformBlockFeatures {
    StructureType sType;
    void *pNext;
    Bool inlineUniformBlock;
    Bool descriptorBindingInlineUniformBlockUpdateAfterBind;
};

struct PhysicalDeviceInlineUniformBlockProperties {
    StructureType sType;
    void *pNext;
    uint32_t maxInlineUniformBlockSize;
    uint32_t maxPerStageDescriptorInlineUniformBlocks;
    uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
    uint32_t maxDescriptorSetInlineUniformBlocks;
    uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
};

struct WriteDescriptorSetInlineUniformBlock {
    StructureType sType;
    const void *pNext;
    uint32_t dataSize;
    const void *pData;
};

struct DescriptorPoolInlineUniformBlockCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t maxInlineUniformBlockBindings;
};

struct PhysicalDeviceTextureCompressionASTCHDRFeatures {
    StructureType sType;
    void *pNext;
    Bool textureCompressionASTC_HDR;
};

struct RenderingAttachmentInfo {
    StructureType sType;
    const void *pNext;
    ImageView imageView;
    ImageLayout imageLayout;
    ResolveMode resolveMode;
    ImageView resolveImageView;
    ImageLayout resolveImageLayout;
    AttachmentLoadOp loadOp;
    AttachmentStoreOp storeOp;
    ClearValue clearValue;
};

struct RenderingInfo {
    StructureType sType;
    const void *pNext;
    RenderingFlags flags;
    Rect2D renderArea;
    uint32_t layerCount;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    const RenderingAttachmentInfo *pColorAttachments;
    const RenderingAttachmentInfo *pDepthAttachment;
    const RenderingAttachmentInfo *pStencilAttachment;
};

struct PipelineRenderingCreateInfo {
    StructureType sType;
    const void *pNext;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    const Format *pColorAttachmentFormats;
    Format depthAttachmentFormat;
    Format stencilAttachmentFormat;
};

struct PhysicalDeviceDynamicRenderingFeatures {
    StructureType sType;
    void *pNext;
    Bool dynamicRendering;
};

struct CommandBufferInheritanceRenderingInfo {
    StructureType sType;
    const void *pNext;
    RenderingFlags flags;
    uint32_t viewMask;
    uint32_t colorAttachmentCount;
    const Format *pColorAttachmentFormats;
    Format depthAttachmentFormat;
    Format stencilAttachmentFormat;
    SampleCount rasterizationSamples;
};

struct PhysicalDeviceShaderIntegerDotProductFeatures {
    StructureType sType;
    void *pNext;
    Bool shaderIntegerDotProduct;
};

struct PhysicalDeviceShaderIntegerDotProductProperties {
    StructureType sType;
    void *pNext;
    Bool integerDotProduct8BitUnsignedAccelerated;
    Bool integerDotProduct8BitSignedAccelerated;
    Bool integerDotProduct8BitMixedSignednessAccelerated;
    Bool integerDotProduct4x8BitPackedUnsignedAccelerated;
    Bool integerDotProduct4x8BitPackedSignedAccelerated;
    Bool integerDotProduct4x8BitPackedMixedSignednessAccelerated;
    Bool integerDotProduct16BitUnsignedAccelerated;
    Bool integerDotProduct16BitSignedAccelerated;
    Bool integerDotProduct16BitMixedSignednessAccelerated;
    Bool integerDotProduct32BitUnsignedAccelerated;
    Bool integerDotProduct32BitSignedAccelerated;
    Bool integerDotProduct32BitMixedSignednessAccelerated;
    Bool integerDotProduct64BitUnsignedAccelerated;
    Bool integerDotProduct64BitSignedAccelerated;
    Bool integerDotProduct64BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating8BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating16BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating32BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
    Bool integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
    Bool integerDotProductAccumulatingSaturating64BitSignedAccelerated;
    Bool integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
};

struct PhysicalDeviceTexelBufferAlignmentProperties {
    StructureType sType;
    void *pNext;
    DeviceSize storageTexelBufferOffsetAlignmentBytes;
    Bool storageTexelBufferOffsetSingleTexelAlignment;
    DeviceSize uniformTexelBufferOffsetAlignmentBytes;
    Bool uniformTexelBufferOffsetSingleTexelAlignment;
};

struct FormatProperties3 {
    StructureType sType;
    void *pNext;
    FormatFeature2 linearTilingFeatures;
    FormatFeature2 optimalTilingFeatures;
    FormatFeature2 bufferFeatures;
};

struct PhysicalDeviceMaintenance4Features {
    StructureType sType;
    void *pNext;
    Bool maintenance4;
};

struct PhysicalDeviceMaintenance4Properties {
    StructureType sType;
    void *pNext;
    DeviceSize maxBufferSize;
};

struct BufferCreateInfo {
    StructureType sType;
    const void *pNext;
    BufferCreateFlags flags;
    DeviceSize size;
    BufferUsage usage;
    SharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    const uint32_t *pQueueFamilyIndices;
};

struct DeviceBufferMemoryRequirements {
    StructureType sType;
    const void *pNext;
    const BufferCreateInfo *pCreateInfo;
};

struct ImageCreateInfo {
    StructureType sType;
    const void *pNext;
    ImageCreateFlags flags;
    ImageType imageType;
    Format format;
    Extent3D extent;
    uint32_t mipLevels;
    uint32_t arrayLayers;
    SampleCount samples;
    ImageTiling tiling;
    ImageUsage usage;
    SharingMode sharingMode;
    uint32_t queueFamilyIndexCount;
    const uint32_t *pQueueFamilyIndices;
    ImageLayout initialLayout;
};

struct DeviceImageMemoryRequirements {
    StructureType sType;
    const void *pNext;
    const ImageCreateInfo *pCreateInfo;
    ImageAspect planeAspect;
};

struct DebugUtilsLabelEXT {
    StructureType sType;
    const void *pNext;
    const char *pLabelName;
    float color [4];
};

struct DebugUtilsObjectNameInfoEXT {
    StructureType sType;
    const void *pNext;
    ObjectType objectType;
    uint64_t objectHandle;
    const char *pObjectName;
};

struct DebugUtilsMessengerCallbackDataEXT {
    StructureType sType;
    const void *pNext;
    DebugUtilsMessengerCallbackDataFlagsEXT flags;
    const char *pMessageIdName;
    int32_t messageIdNumber;
    const char *pMessage;
    uint32_t queueLabelCount;
    const DebugUtilsLabelEXT *pQueueLabels;
    uint32_t cmdBufLabelCount;
    const DebugUtilsLabelEXT *pCmdBufLabels;
    uint32_t objectCount;
    const DebugUtilsObjectNameInfoEXT *pObjects;
};

typedef Bool (VKAPI_PTR *PFN_vkDebugUtilsMessengerCallbackEXT)(
    DebugUtilsMessageSeverityFlagsEXT           messageSeverity,
    DebugUtilsMessageTypeFlagsEXT                  messageTypes,
    const DebugUtilsMessengerCallbackDataEXT*      pCallbackData,
    void*                                            pUserData); 

struct DebugUtilsMessengerCreateInfoEXT {
    StructureType sType;
    const void *pNext;
    DebugUtilsMessengerCreateFlagsEXT flags;
    DebugUtilsMessageSeverityFlagsEXT messageSeverity;
    DebugUtilsMessageTypeFlagsEXT messageType;
    PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback;
    void *pUserData;
};

struct DebugUtilsObjectTagInfoEXT {
    StructureType sType;
    const void *pNext;
    ObjectType objectType;
    uint64_t objectHandle;
    uint64_t tagName;
    size_t tagSize;
    const void *pTag;
};

struct PhysicalDeviceDescriptorBufferPropertiesEXT {
    StructureType sType;
    void *pNext;
    Bool combinedImageSamplerDescriptorSingleArray;
    Bool bufferlessPushDescriptors;
    Bool allowSamplerImageViewPostSubmitCreation;
    DeviceSize descriptorBufferOffsetAlignment;
    uint32_t maxDescriptorBufferBindings;
    uint32_t maxResourceDescriptorBufferBindings;
    uint32_t maxSamplerDescriptorBufferBindings;
    uint32_t maxEmbeddedImmutableSamplerBindings;
    uint32_t maxEmbeddedImmutableSamplers;
    size_t bufferCaptureReplayDescriptorDataSize;
    size_t imageCaptureReplayDescriptorDataSize;
    size_t imageViewCaptureReplayDescriptorDataSize;
    size_t samplerCaptureReplayDescriptorDataSize;
    size_t accelerationStructureCaptureReplayDescriptorDataSize;
    size_t samplerDescriptorSize;
    size_t combinedImageSamplerDescriptorSize;
    size_t sampledImageDescriptorSize;
    size_t storageImageDescriptorSize;
    size_t uniformTexelBufferDescriptorSize;
    size_t robustUniformTexelBufferDescriptorSize;
    size_t storageTexelBufferDescriptorSize;
    size_t robustStorageTexelBufferDescriptorSize;
    size_t uniformBufferDescriptorSize;
    size_t robustUniformBufferDescriptorSize;
    size_t storageBufferDescriptorSize;
    size_t robustStorageBufferDescriptorSize;
    size_t inputAttachmentDescriptorSize;
    size_t accelerationStructureDescriptorSize;
    DeviceSize maxSamplerDescriptorBufferRange;
    DeviceSize maxResourceDescriptorBufferRange;
    DeviceSize samplerDescriptorBufferAddressSpaceSize;
    DeviceSize resourceDescriptorBufferAddressSpaceSize;
    DeviceSize descriptorBufferAddressSpaceSize;
};

struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    StructureType sType;
    void *pNext;
    size_t combinedImageSamplerDensityMapDescriptorSize;
};

struct PhysicalDeviceDescriptorBufferFeaturesEXT {
    StructureType sType;
    void *pNext;
    Bool descriptorBuffer;
    Bool descriptorBufferCaptureReplay;
    Bool descriptorBufferImageLayoutIgnored;
    Bool descriptorBufferPushDescriptors;
};

struct DescriptorBufferBindingInfoEXT {
    StructureType sType;
    const void *pNext;
    DeviceAddress address;
    BufferUsage usage;
};

struct DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
};

struct DescriptorAddressInfoEXT {
    StructureType sType;
    void *pNext;
    DeviceAddress address;
    DeviceSize range;
    Format format;
};

union DescriptorDataEXT {
    const Sampler *pSampler;
    const DescriptorImageInfo *pCombinedImageSampler;
    const DescriptorImageInfo *pInputAttachmentImage;
    const DescriptorImageInfo *pSampledImage;
    const DescriptorImageInfo *pStorageImage;
    const DescriptorAddressInfoEXT *pUniformTexelBuffer;
    const DescriptorAddressInfoEXT *pStorageTexelBuffer;
    const DescriptorAddressInfoEXT *pUniformBuffer;
    const DescriptorAddressInfoEXT *pStorageBuffer;
    DeviceAddress accelerationStructure;
};

struct DescriptorGetInfoEXT {
    StructureType sType;
    const void *pNext;
    DescriptorType type;
    DescriptorDataEXT data;
};

struct BufferCaptureDescriptorDataInfoEXT {
    StructureType sType;
    const void *pNext;
    Buffer buffer;
};

struct ImageCaptureDescriptorDataInfoEXT {
    StructureType sType;
    const void *pNext;
    Image image;
};

struct ImageViewCaptureDescriptorDataInfoEXT {
    StructureType sType;
    const void *pNext;
    ImageView imageView;
};

struct SamplerCaptureDescriptorDataInfoEXT {
    StructureType sType;
    const void *pNext;
    Sampler sampler;
};

struct OpaqueCaptureDescriptorDataCreateInfoEXT {
    StructureType sType;
    const void *pNext;
    const void *opaqueCaptureDescriptorData;
};

struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    StructureType sType;
    void *pNext;
    Bool shaderBufferFloat32Atomics;
    Bool shaderBufferFloat32AtomicAdd;
    Bool shaderBufferFloat64Atomics;
    Bool shaderBufferFloat64AtomicAdd;
    Bool shaderSharedFloat32Atomics;
    Bool shaderSharedFloat32AtomicAdd;
    Bool shaderSharedFloat64Atomics;
    Bool shaderSharedFloat64AtomicAdd;
    Bool shaderImageFloat32Atomics;
    Bool shaderImageFloat32AtomicAdd;
    Bool sparseImageFloat32Atomics;
    Bool sparseImageFloat32AtomicAdd;
};

struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    StructureType sType;
    void *pNext;
    Bool shaderBufferFloat16Atomics;
    Bool shaderBufferFloat16AtomicAdd;
    Bool shaderBufferFloat16AtomicMinMax;
    Bool shaderBufferFloat32AtomicMinMax;
    Bool shaderBufferFloat64AtomicMinMax;
    Bool shaderSharedFloat16Atomics;
    Bool shaderSharedFloat16AtomicAdd;
    Bool shaderSharedFloat16AtomicMinMax;
    Bool shaderSharedFloat32AtomicMinMax;
    Bool shaderSharedFloat64AtomicMinMax;
    Bool shaderImageFloat32AtomicMinMax;
    Bool sparseImageFloat32AtomicMinMax;
};

struct ValidationFeaturesEXT {
    StructureType sType;
    const void *pNext;
    uint32_t enabledValidationFeatureCount;
    const ValidationFeatureEnableEXT *pEnabledValidationFeatures;
    uint32_t disabledValidationFeatureCount;
    const ValidationFeatureDisableEXT *pDisabledValidationFeatures;
};

struct SurfaceCapabilitiesKHR {
    uint32_t minImageCount;
    uint32_t maxImageCount;
    Extent2D currentExtent;
    Extent2D minImageExtent;
    Extent2D maxImageExtent;
    uint32_t maxImageArrayLayers;
    SurfaceTransformFlagsKHR supportedTransforms;
    SurfaceTransformFlagsKHR currentTransform;
    CompositeAlphaFlagsKHR supportedCompositeAlpha;
    ImageUsage supportedUsage;
};

struct SurfaceFormatKHR {
    Format format;
    ColorSpaceKHR colorSpace;
};

struct SwapchainCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainCreateFlagsKHR flags;
    SurfaceKHR surface;
    uint32_t minImageCount;
    Format imageFormat;
    ColorSpaceKHR imageColorSpace;
    Extent2D imageExtent;
    uint32_t imageArrayLayers;
    ImageUsage imageUsage;
    SharingMode imageSharingMode;
    uint32_t queueFamilyIndexCount;
    const uint32_t *pQueueFamilyIndices;
    SurfaceTransformFlagsKHR preTransform;
    CompositeAlphaFlagsKHR compositeAlpha;
    PresentModeKHR presentMode;
    Bool clipped;
    SwapchainKHR oldSwapchain;
};

struct PresentInfoKHR {
    StructureType sType;
    const void *pNext;
    uint32_t waitSemaphoreCount;
    const Semaphore *pWaitSemaphores;
    uint32_t swapchainCount;
    const SwapchainKHR *pSwapchains;
    const uint32_t *pImageIndices;
    Result *pResults;
};

struct ImageSwapchainCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainKHR swapchain;
};

struct BindImageMemorySwapchainInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainKHR swapchain;
    uint32_t imageIndex;
};

struct AcquireNextImageInfoKHR {
    StructureType sType;
    const void *pNext;
    SwapchainKHR swapchain;
    uint64_t timeout;
    Semaphore semaphore;
    Fence fence;
    uint32_t deviceMask;
};

struct DeviceGroupPresentCapabilitiesKHR {
    StructureType sType;
    void *pNext;
    uint32_t presentMask [k_max_device_group_size ];
    DeviceGroupPresentModeKHR modes;
};

struct DeviceGroupPresentInfoKHR {
    StructureType sType;
    const void *pNext;
    uint32_t swapchainCount;
    const uint32_t *pDeviceMasks;
    DeviceGroupPresentModeKHR mode;
};

struct DeviceGroupSwapchainCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    DeviceGroupPresentModeKHR modes;
};

struct XcbSurfaceCreateInfoKHR {
    StructureType sType;
    const void *pNext;
    XcbSurfaceCreateFlagsKHR flags;
    xcb_connection_t *connection;
    xcb_window_t window;
};

// Command function pointers.
using PFN_vkAcquireNextImage2KHR = Result (*)(Device device, const AcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex);
using PFN_vkAcquireNextImageKHR = Result (*)(Device device, SwapchainKHR swapchain, uint64_t timeout, Semaphore semaphore, Fence fence, uint32_t *pImageIndex);
using PFN_vkAllocateCommandBuffers = Result (*)(Device device, const CommandBufferAllocateInfo *pAllocateInfo, CommandBuffer *pCommandBuffers);
using PFN_vkAllocateDescriptorSets = Result (*)(Device device, const DescriptorSetAllocateInfo *pAllocateInfo, DescriptorSet *pDescriptorSets);
using PFN_vkAllocateMemory = Result (*)(Device device, const MemoryAllocateInfo *pAllocateInfo, const AllocationCallbacks *pAllocator, DeviceMemory *pMemory);
using PFN_vkBeginCommandBuffer = Result (*)(CommandBuffer commandBuffer, const CommandBufferBeginInfo *pBeginInfo);
using PFN_vkBindBufferMemory = Result (*)(Device device, Buffer buffer, DeviceMemory memory, DeviceSize memoryOffset);
using PFN_vkBindBufferMemory2 = Result (*)(Device device, uint32_t bindInfoCount, const BindBufferMemoryInfo *pBindInfos);
using PFN_vkBindImageMemory = Result (*)(Device device, Image image, DeviceMemory memory, DeviceSize memoryOffset);
using PFN_vkBindImageMemory2 = Result (*)(Device device, uint32_t bindInfoCount, const BindImageMemoryInfo *pBindInfos);
using PFN_vkCmdBeginDebugUtilsLabelEXT = void (*)(CommandBuffer commandBuffer, const DebugUtilsLabelEXT *pLabelInfo);
using PFN_vkCmdBeginQuery = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query, QueryControlFlags flags);
using PFN_vkCmdBeginRenderPass = void (*)(CommandBuffer commandBuffer, const RenderPassBeginInfo *pRenderPassBegin, SubpassContents contents);
using PFN_vkCmdBeginRenderPass2 = void (*)(CommandBuffer commandBuffer, const RenderPassBeginInfo *pRenderPassBegin, const SubpassBeginInfo *pSubpassBeginInfo);
using PFN_vkCmdBeginRendering = void (*)(CommandBuffer commandBuffer, const RenderingInfo *pRenderingInfo);
using PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = void (*)(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t set);
using PFN_vkCmdBindDescriptorBuffersEXT = void (*)(CommandBuffer commandBuffer, uint32_t bufferCount, const DescriptorBufferBindingInfoEXT *pBindingInfos);
using PFN_vkCmdBindDescriptorSets = void (*)(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const DescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets);
using PFN_vkCmdBindIndexBuffer = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, IndexType indexType);
using PFN_vkCmdBindPipeline = void (*)(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, Pipeline pipeline);
using PFN_vkCmdBindVertexBuffers = void (*)(CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer *pBuffers, const DeviceSize *pOffsets);
using PFN_vkCmdBindVertexBuffers2 = void (*)(CommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const Buffer *pBuffers, const DeviceSize *pOffsets, const DeviceSize *pSizes, const DeviceSize *pStrides);
using PFN_vkCmdBlitImage = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageBlit *pRegions, Filter filter);
using PFN_vkCmdBlitImage2 = void (*)(CommandBuffer commandBuffer, const BlitImageInfo2 *pBlitImageInfo);
using PFN_vkCmdClearAttachments = void (*)(CommandBuffer commandBuffer, uint32_t attachmentCount, const ClearAttachment *pAttachments, uint32_t rectCount, const ClearRect *pRects);
using PFN_vkCmdClearColorImage = void (*)(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearColorValue *pColor, uint32_t rangeCount, const ImageSubresourceRange *pRanges);
using PFN_vkCmdClearDepthStencilImage = void (*)(CommandBuffer commandBuffer, Image image, ImageLayout imageLayout, const ClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const ImageSubresourceRange *pRanges);
using PFN_vkCmdCopyBuffer = void (*)(CommandBuffer commandBuffer, Buffer srcBuffer, Buffer dstBuffer, uint32_t regionCount, const BufferCopy *pRegions);
using PFN_vkCmdCopyBuffer2 = void (*)(CommandBuffer commandBuffer, const CopyBufferInfo2 *pCopyBufferInfo);
using PFN_vkCmdCopyBufferToImage = void (*)(CommandBuffer commandBuffer, Buffer srcBuffer, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const BufferImageCopy *pRegions);
using PFN_vkCmdCopyBufferToImage2 = void (*)(CommandBuffer commandBuffer, const CopyBufferToImageInfo2 *pCopyBufferToImageInfo);
using PFN_vkCmdCopyImage = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageCopy *pRegions);
using PFN_vkCmdCopyImage2 = void (*)(CommandBuffer commandBuffer, const CopyImageInfo2 *pCopyImageInfo);
using PFN_vkCmdCopyImageToBuffer = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Buffer dstBuffer, uint32_t regionCount, const BufferImageCopy *pRegions);
using PFN_vkCmdCopyImageToBuffer2 = void (*)(CommandBuffer commandBuffer, const CopyImageToBufferInfo2 *pCopyImageToBufferInfo);
using PFN_vkCmdCopyQueryPoolResults = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize stride, QueryResultFlags flags);
using PFN_vkCmdDispatch = void (*)(CommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
using PFN_vkCmdDispatchBase = void (*)(CommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ);
using PFN_vkCmdDispatchIndirect = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset);
using PFN_vkCmdDraw = void (*)(CommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance);
using PFN_vkCmdDrawIndexed = void (*)(CommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance);
using PFN_vkCmdDrawIndexedIndirect = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride);
using PFN_vkCmdDrawIndexedIndirectCount = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
using PFN_vkCmdDrawIndirect = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, uint32_t drawCount, uint32_t stride);
using PFN_vkCmdDrawIndirectCount = void (*)(CommandBuffer commandBuffer, Buffer buffer, DeviceSize offset, Buffer countBuffer, DeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);
using PFN_vkCmdEndDebugUtilsLabelEXT = void (*)(CommandBuffer commandBuffer);
using PFN_vkCmdEndQuery = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t query);
using PFN_vkCmdEndRenderPass = void (*)(CommandBuffer commandBuffer);
using PFN_vkCmdEndRenderPass2 = void (*)(CommandBuffer commandBuffer, const SubpassEndInfo *pSubpassEndInfo);
using PFN_vkCmdEndRendering = void (*)(CommandBuffer commandBuffer);
using PFN_vkCmdExecuteCommands = void (*)(CommandBuffer commandBuffer, uint32_t commandBufferCount, const CommandBuffer *pCommandBuffers);
using PFN_vkCmdFillBuffer = void (*)(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize size, uint32_t data);
using PFN_vkCmdInsertDebugUtilsLabelEXT = void (*)(CommandBuffer commandBuffer, const DebugUtilsLabelEXT *pLabelInfo);
using PFN_vkCmdNextSubpass = void (*)(CommandBuffer commandBuffer, SubpassContents contents);
using PFN_vkCmdNextSubpass2 = void (*)(CommandBuffer commandBuffer, const SubpassBeginInfo *pSubpassBeginInfo, const SubpassEndInfo *pSubpassEndInfo);
using PFN_vkCmdPipelineBarrier = void (*)(CommandBuffer commandBuffer, PipelineStage srcStageMask, PipelineStage dstStageMask, DependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const MemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier *pImageMemoryBarriers);
using PFN_vkCmdPipelineBarrier2 = void (*)(CommandBuffer commandBuffer, const DependencyInfo *pDependencyInfo);
using PFN_vkCmdPushConstants = void (*)(CommandBuffer commandBuffer, PipelineLayout layout, ShaderStage stageFlags, uint32_t offset, uint32_t size, const void *pValues);
using PFN_vkCmdResetEvent = void (*)(CommandBuffer commandBuffer, Event event, PipelineStage stageMask);
using PFN_vkCmdResetEvent2 = void (*)(CommandBuffer commandBuffer, Event event, PipelineStage2 stageMask);
using PFN_vkCmdResetQueryPool = void (*)(CommandBuffer commandBuffer, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
using PFN_vkCmdResolveImage = void (*)(CommandBuffer commandBuffer, Image srcImage, ImageLayout srcImageLayout, Image dstImage, ImageLayout dstImageLayout, uint32_t regionCount, const ImageResolve *pRegions);
using PFN_vkCmdResolveImage2 = void (*)(CommandBuffer commandBuffer, const ResolveImageInfo2 *pResolveImageInfo);
using PFN_vkCmdSetBlendConstants = void (*)(CommandBuffer commandBuffer, const float blendConstants [4]);
using PFN_vkCmdSetCullMode = void (*)(CommandBuffer commandBuffer, CullMode cullMode);
using PFN_vkCmdSetDepthBias = void (*)(CommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor);
using PFN_vkCmdSetDepthBiasEnable = void (*)(CommandBuffer commandBuffer, Bool depthBiasEnable);
using PFN_vkCmdSetDepthBounds = void (*)(CommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds);
using PFN_vkCmdSetDepthBoundsTestEnable = void (*)(CommandBuffer commandBuffer, Bool depthBoundsTestEnable);
using PFN_vkCmdSetDepthCompareOp = void (*)(CommandBuffer commandBuffer, CompareOp depthCompareOp);
using PFN_vkCmdSetDepthTestEnable = void (*)(CommandBuffer commandBuffer, Bool depthTestEnable);
using PFN_vkCmdSetDepthWriteEnable = void (*)(CommandBuffer commandBuffer, Bool depthWriteEnable);
using PFN_vkCmdSetDescriptorBufferOffsetsEXT = void (*)(CommandBuffer commandBuffer, PipelineBindPoint pipelineBindPoint, PipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const DeviceSize *pOffsets);
using PFN_vkCmdSetDeviceMask = void (*)(CommandBuffer commandBuffer, uint32_t deviceMask);
using PFN_vkCmdSetEvent = void (*)(CommandBuffer commandBuffer, Event event, PipelineStage stageMask);
using PFN_vkCmdSetEvent2 = void (*)(CommandBuffer commandBuffer, Event event, const DependencyInfo *pDependencyInfo);
using PFN_vkCmdSetFrontFace = void (*)(CommandBuffer commandBuffer, FrontFace frontFace);
using PFN_vkCmdSetLineWidth = void (*)(CommandBuffer commandBuffer, float lineWidth);
using PFN_vkCmdSetPrimitiveRestartEnable = void (*)(CommandBuffer commandBuffer, Bool primitiveRestartEnable);
using PFN_vkCmdSetPrimitiveTopology = void (*)(CommandBuffer commandBuffer, PrimitiveTopology primitiveTopology);
using PFN_vkCmdSetRasterizerDiscardEnable = void (*)(CommandBuffer commandBuffer, Bool rasterizerDiscardEnable);
using PFN_vkCmdSetScissor = void (*)(CommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const Rect2D *pScissors);
using PFN_vkCmdSetScissorWithCount = void (*)(CommandBuffer commandBuffer, uint32_t scissorCount, const Rect2D *pScissors);
using PFN_vkCmdSetStencilCompareMask = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t compareMask);
using PFN_vkCmdSetStencilOp = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, StencilOp failOp, StencilOp passOp, StencilOp depthFailOp, CompareOp compareOp);
using PFN_vkCmdSetStencilReference = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t reference);
using PFN_vkCmdSetStencilTestEnable = void (*)(CommandBuffer commandBuffer, Bool stencilTestEnable);
using PFN_vkCmdSetStencilWriteMask = void (*)(CommandBuffer commandBuffer, StencilFaceFlags faceMask, uint32_t writeMask);
using PFN_vkCmdSetViewport = void (*)(CommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const Viewport *pViewports);
using PFN_vkCmdSetViewportWithCount = void (*)(CommandBuffer commandBuffer, uint32_t viewportCount, const Viewport *pViewports);
using PFN_vkCmdUpdateBuffer = void (*)(CommandBuffer commandBuffer, Buffer dstBuffer, DeviceSize dstOffset, DeviceSize dataSize, const void *pData);
using PFN_vkCmdWaitEvents = void (*)(CommandBuffer commandBuffer, uint32_t eventCount, const Event *pEvents, PipelineStage srcStageMask, PipelineStage dstStageMask, uint32_t memoryBarrierCount, const MemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const BufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const ImageMemoryBarrier *pImageMemoryBarriers);
using PFN_vkCmdWaitEvents2 = void (*)(CommandBuffer commandBuffer, uint32_t eventCount, const Event *pEvents, const DependencyInfo *pDependencyInfos);
using PFN_vkCmdWriteTimestamp = void (*)(CommandBuffer commandBuffer, PipelineStage pipelineStage, QueryPool queryPool, uint32_t query);
using PFN_vkCmdWriteTimestamp2 = void (*)(CommandBuffer commandBuffer, PipelineStage2 stage, QueryPool queryPool, uint32_t query);
using PFN_vkCreateBuffer = Result (*)(Device device, const BufferCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Buffer *pBuffer);
using PFN_vkCreateBufferView = Result (*)(Device device, const BufferViewCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, BufferView *pView);
using PFN_vkCreateCommandPool = Result (*)(Device device, const CommandPoolCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, CommandPool *pCommandPool);
using PFN_vkCreateComputePipelines = Result (*)(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const ComputePipelineCreateInfo *pCreateInfos, const AllocationCallbacks *pAllocator, Pipeline *pPipelines);
using PFN_vkCreateDebugUtilsMessengerEXT = Result (*)(Instance instance, const DebugUtilsMessengerCreateInfoEXT *pCreateInfo, const AllocationCallbacks *pAllocator, DebugUtilsMessengerEXT *pMessenger);
using PFN_vkCreateDescriptorPool = Result (*)(Device device, const DescriptorPoolCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, DescriptorPool *pDescriptorPool);
using PFN_vkCreateDescriptorSetLayout = Result (*)(Device device, const DescriptorSetLayoutCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, DescriptorSetLayout *pSetLayout);
using PFN_vkCreateDescriptorUpdateTemplate = Result (*)(Device device, const DescriptorUpdateTemplateCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, DescriptorUpdateTemplate *pDescriptorUpdateTemplate);
using PFN_vkCreateDevice = Result (*)(PhysicalDevice physicalDevice, const DeviceCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Device *pDevice);
using PFN_vkCreateEvent = Result (*)(Device device, const EventCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Event *pEvent);
using PFN_vkCreateFence = Result (*)(Device device, const FenceCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Fence *pFence);
using PFN_vkCreateFramebuffer = Result (*)(Device device, const FramebufferCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Framebuffer *pFramebuffer);
using PFN_vkCreateGraphicsPipelines = Result (*)(Device device, PipelineCache pipelineCache, uint32_t createInfoCount, const GraphicsPipelineCreateInfo *pCreateInfos, const AllocationCallbacks *pAllocator, Pipeline *pPipelines);
using PFN_vkCreateImage = Result (*)(Device device, const ImageCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Image *pImage);
using PFN_vkCreateImageView = Result (*)(Device device, const ImageViewCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, ImageView *pView);
using PFN_vkCreateInstance = Result (*)(const InstanceCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Instance *pInstance);
using PFN_vkCreatePipelineCache = Result (*)(Device device, const PipelineCacheCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, PipelineCache *pPipelineCache);
using PFN_vkCreatePipelineLayout = Result (*)(Device device, const PipelineLayoutCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, PipelineLayout *pPipelineLayout);
using PFN_vkCreatePrivateDataSlot = Result (*)(Device device, const PrivateDataSlotCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, PrivateDataSlot *pPrivateDataSlot);
using PFN_vkCreateQueryPool = Result (*)(Device device, const QueryPoolCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, QueryPool *pQueryPool);
using PFN_vkCreateRenderPass = Result (*)(Device device, const RenderPassCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, RenderPass *pRenderPass);
using PFN_vkCreateRenderPass2 = Result (*)(Device device, const RenderPassCreateInfo2 *pCreateInfo, const AllocationCallbacks *pAllocator, RenderPass *pRenderPass);
using PFN_vkCreateSampler = Result (*)(Device device, const SamplerCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Sampler *pSampler);
using PFN_vkCreateSamplerYcbcrConversion = Result (*)(Device device, const SamplerYcbcrConversionCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, SamplerYcbcrConversion *pYcbcrConversion);
using PFN_vkCreateSemaphore = Result (*)(Device device, const SemaphoreCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, Semaphore *pSemaphore);
using PFN_vkCreateShaderModule = Result (*)(Device device, const ShaderModuleCreateInfo *pCreateInfo, const AllocationCallbacks *pAllocator, ShaderModule *pShaderModule);
using PFN_vkCreateSwapchainKHR = Result (*)(Device device, const SwapchainCreateInfoKHR *pCreateInfo, const AllocationCallbacks *pAllocator, SwapchainKHR *pSwapchain);
using PFN_vkCreateXcbSurfaceKHR = Result (*)(Instance instance, const XcbSurfaceCreateInfoKHR *pCreateInfo, const AllocationCallbacks *pAllocator, SurfaceKHR *pSurface);
using PFN_vkDestroyBuffer = void (*)(Device device, Buffer buffer, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyBufferView = void (*)(Device device, BufferView bufferView, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyCommandPool = void (*)(Device device, CommandPool commandPool, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyDebugUtilsMessengerEXT = void (*)(Instance instance, DebugUtilsMessengerEXT messenger, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyDescriptorPool = void (*)(Device device, DescriptorPool descriptorPool, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyDescriptorSetLayout = void (*)(Device device, DescriptorSetLayout descriptorSetLayout, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyDescriptorUpdateTemplate = void (*)(Device device, DescriptorUpdateTemplate descriptorUpdateTemplate, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyDevice = void (*)(Device device, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyEvent = void (*)(Device device, Event event, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyFence = void (*)(Device device, Fence fence, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyFramebuffer = void (*)(Device device, Framebuffer framebuffer, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyImage = void (*)(Device device, Image image, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyImageView = void (*)(Device device, ImageView imageView, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyInstance = void (*)(Instance instance, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyPipeline = void (*)(Device device, Pipeline pipeline, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyPipelineCache = void (*)(Device device, PipelineCache pipelineCache, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyPipelineLayout = void (*)(Device device, PipelineLayout pipelineLayout, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyPrivateDataSlot = void (*)(Device device, PrivateDataSlot privateDataSlot, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyQueryPool = void (*)(Device device, QueryPool queryPool, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyRenderPass = void (*)(Device device, RenderPass renderPass, const AllocationCallbacks *pAllocator);
using PFN_vkDestroySampler = void (*)(Device device, Sampler sampler, const AllocationCallbacks *pAllocator);
using PFN_vkDestroySamplerYcbcrConversion = void (*)(Device device, SamplerYcbcrConversion ycbcrConversion, const AllocationCallbacks *pAllocator);
using PFN_vkDestroySemaphore = void (*)(Device device, Semaphore semaphore, const AllocationCallbacks *pAllocator);
using PFN_vkDestroyShaderModule = void (*)(Device device, ShaderModule shaderModule, const AllocationCallbacks *pAllocator);
using PFN_vkDestroySurfaceKHR = void (*)(Instance instance, SurfaceKHR surface, const AllocationCallbacks *pAllocator);
using PFN_vkDestroySwapchainKHR = void (*)(Device device, SwapchainKHR swapchain, const AllocationCallbacks *pAllocator);
using PFN_vkDeviceWaitIdle = Result (*)(Device device);
using PFN_vkEndCommandBuffer = Result (*)(CommandBuffer commandBuffer);
using PFN_vkEnumerateDeviceExtensionProperties = Result (*)(PhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, ExtensionProperties *pProperties);
using PFN_vkEnumerateDeviceLayerProperties = Result (*)(PhysicalDevice physicalDevice, uint32_t *pPropertyCount, LayerProperties *pProperties);
using PFN_vkEnumerateInstanceExtensionProperties = Result (*)(const char *pLayerName, uint32_t *pPropertyCount, ExtensionProperties *pProperties);
using PFN_vkEnumerateInstanceLayerProperties = Result (*)(uint32_t *pPropertyCount, LayerProperties *pProperties);
using PFN_vkEnumerateInstanceVersion = Result (*)(uint32_t *pApiVersion);
using PFN_vkEnumeratePhysicalDeviceGroups = Result (*)(Instance instance, uint32_t *pPhysicalDeviceGroupCount, PhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties);
using PFN_vkEnumeratePhysicalDevices = Result (*)(Instance instance, uint32_t *pPhysicalDeviceCount, PhysicalDevice *pPhysicalDevices);
using PFN_vkFlushMappedMemoryRanges = Result (*)(Device device, uint32_t memoryRangeCount, const MappedMemoryRange *pMemoryRanges);
using PFN_vkFreeCommandBuffers = void (*)(Device device, CommandPool commandPool, uint32_t commandBufferCount, const CommandBuffer *pCommandBuffers);
using PFN_vkFreeDescriptorSets = Result (*)(Device device, DescriptorPool descriptorPool, uint32_t descriptorSetCount, const DescriptorSet *pDescriptorSets);
using PFN_vkFreeMemory = void (*)(Device device, DeviceMemory memory, const AllocationCallbacks *pAllocator);
using PFN_vkGetBufferDeviceAddress = DeviceAddress (*)(Device device, const BufferDeviceAddressInfo *pInfo);
using PFN_vkGetBufferMemoryRequirements = void (*)(Device device, Buffer buffer, MemoryRequirements *pMemoryRequirements);
using PFN_vkGetBufferMemoryRequirements2 = void (*)(Device device, const BufferMemoryRequirementsInfo2 *pInfo, MemoryRequirements2 *pMemoryRequirements);
using PFN_vkGetBufferOpaqueCaptureAddress = uint64_t (*)(Device device, const BufferDeviceAddressInfo *pInfo);
using PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = Result (*)(Device device, const BufferCaptureDescriptorDataInfoEXT *pInfo, void *pData);
using PFN_vkGetDescriptorEXT = void (*)(Device device, const DescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor);
using PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = void (*)(Device device, DescriptorSetLayout layout, uint32_t binding, DeviceSize *pOffset);
using PFN_vkGetDescriptorSetLayoutSizeEXT = void (*)(Device device, DescriptorSetLayout layout, DeviceSize *pLayoutSizeInBytes);
using PFN_vkGetDescriptorSetLayoutSupport = void (*)(Device device, const DescriptorSetLayoutCreateInfo *pCreateInfo, DescriptorSetLayoutSupport *pSupport);
using PFN_vkGetDeviceBufferMemoryRequirements = void (*)(Device device, const DeviceBufferMemoryRequirements *pInfo, MemoryRequirements2 *pMemoryRequirements);
using PFN_vkGetDeviceGroupPeerMemoryFeatures = void (*)(Device device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, PeerMemoryFeature *pPeerMemoryFeatures);
using PFN_vkGetDeviceGroupPresentCapabilitiesKHR = Result (*)(Device device, DeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities);
using PFN_vkGetDeviceGroupSurfacePresentModesKHR = Result (*)(Device device, SurfaceKHR surface, DeviceGroupPresentModeKHR *pModes);
using PFN_vkGetDeviceImageMemoryRequirements = void (*)(Device device, const DeviceImageMemoryRequirements *pInfo, MemoryRequirements2 *pMemoryRequirements);
using PFN_vkGetDeviceImageSparseMemoryRequirements = void (*)(Device device, const DeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, SparseImageMemoryRequirements2 *pSparseMemoryRequirements);
using PFN_vkGetDeviceMemoryCommitment = void (*)(Device device, DeviceMemory memory, DeviceSize *pCommittedMemoryInBytes);
using PFN_vkGetDeviceMemoryOpaqueCaptureAddress = uint64_t (*)(Device device, const DeviceMemoryOpaqueCaptureAddressInfo *pInfo);
using PFN_vkGetDeviceProcAddr = PFN_vkVoidFunction (*)(Device device, const char *pName);
using PFN_vkGetDeviceQueue = void (*)(Device device, uint32_t queueFamilyIndex, uint32_t queueIndex, Queue *pQueue);
using PFN_vkGetDeviceQueue2 = void (*)(Device device, const DeviceQueueInfo2 *pQueueInfo, Queue *pQueue);
using PFN_vkGetEventStatus = Result (*)(Device device, Event event);
using PFN_vkGetFenceStatus = Result (*)(Device device, Fence fence);
using PFN_vkGetImageMemoryRequirements = void (*)(Device device, Image image, MemoryRequirements *pMemoryRequirements);
using PFN_vkGetImageMemoryRequirements2 = void (*)(Device device, const ImageMemoryRequirementsInfo2 *pInfo, MemoryRequirements2 *pMemoryRequirements);
using PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = Result (*)(Device device, const ImageCaptureDescriptorDataInfoEXT *pInfo, void *pData);
using PFN_vkGetImageSparseMemoryRequirements = void (*)(Device device, Image image, uint32_t *pSparseMemoryRequirementCount, SparseImageMemoryRequirements *pSparseMemoryRequirements);
using PFN_vkGetImageSparseMemoryRequirements2 = void (*)(Device device, const ImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, SparseImageMemoryRequirements2 *pSparseMemoryRequirements);
using PFN_vkGetImageSubresourceLayout = void (*)(Device device, Image image, const ImageSubresource *pSubresource, SubresourceLayout *pLayout);
using PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = Result (*)(Device device, const ImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData);
using PFN_vkGetInstanceProcAddr = PFN_vkVoidFunction (*)(Instance instance, const char *pName);
using PFN_vkGetPhysicalDeviceExternalBufferProperties = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceExternalBufferInfo *pExternalBufferInfo, ExternalBufferProperties *pExternalBufferProperties);
using PFN_vkGetPhysicalDeviceExternalFenceProperties = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceExternalFenceInfo *pExternalFenceInfo, ExternalFenceProperties *pExternalFenceProperties);
using PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, ExternalSemaphoreProperties *pExternalSemaphoreProperties);
using PFN_vkGetPhysicalDeviceFeatures = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceFeatures *pFeatures);
using PFN_vkGetPhysicalDeviceFeatures2 = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceFeatures2 *pFeatures);
using PFN_vkGetPhysicalDeviceFormatProperties = void (*)(PhysicalDevice physicalDevice, Format format, FormatProperties *pFormatProperties);
using PFN_vkGetPhysicalDeviceFormatProperties2 = void (*)(PhysicalDevice physicalDevice, Format format, FormatProperties2 *pFormatProperties);
using PFN_vkGetPhysicalDeviceImageFormatProperties = Result (*)(PhysicalDevice physicalDevice, Format format, ImageType type, ImageTiling tiling, ImageUsage usage, ImageCreateFlags flags, ImageFormatProperties *pImageFormatProperties);
using PFN_vkGetPhysicalDeviceImageFormatProperties2 = Result (*)(PhysicalDevice physicalDevice, const PhysicalDeviceImageFormatInfo2 *pImageFormatInfo, ImageFormatProperties2 *pImageFormatProperties);
using PFN_vkGetPhysicalDeviceMemoryProperties = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceMemoryProperties *pMemoryProperties);
using PFN_vkGetPhysicalDeviceMemoryProperties2 = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceMemoryProperties2 *pMemoryProperties);
using PFN_vkGetPhysicalDevicePresentRectanglesKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t *pRectCount, Rect2D *pRects);
using PFN_vkGetPhysicalDeviceProperties = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceProperties *pProperties);
using PFN_vkGetPhysicalDeviceProperties2 = void (*)(PhysicalDevice physicalDevice, PhysicalDeviceProperties2 *pProperties);
using PFN_vkGetPhysicalDeviceQueueFamilyProperties = void (*)(PhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, QueueFamilyProperties *pQueueFamilyProperties);
using PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = void (*)(PhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, QueueFamilyProperties2 *pQueueFamilyProperties);
using PFN_vkGetPhysicalDeviceSparseImageFormatProperties = void (*)(PhysicalDevice physicalDevice, Format format, ImageType type, SampleCount samples, ImageUsage usage, ImageTiling tiling, uint32_t *pPropertyCount, SparseImageFormatProperties *pProperties);
using PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = void (*)(PhysicalDevice physicalDevice, const PhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, SparseImageFormatProperties2 *pProperties);
using PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, SurfaceCapabilitiesKHR *pSurfaceCapabilities);
using PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t *pSurfaceFormatCount, SurfaceFormatKHR *pSurfaceFormats);
using PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = Result (*)(PhysicalDevice physicalDevice, SurfaceKHR surface, uint32_t *pPresentModeCount, PresentModeKHR *pPresentModes);
using PFN_vkGetPhysicalDeviceSurfaceSupportKHR = Result (*)(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, SurfaceKHR surface, Bool *pSupported);
using PFN_vkGetPhysicalDeviceToolProperties = Result (*)(PhysicalDevice physicalDevice, uint32_t *pToolCount, PhysicalDeviceToolProperties *pToolProperties);
using PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR = Bool (*)(PhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id);
using PFN_vkGetPipelineCacheData = Result (*)(Device device, PipelineCache pipelineCache, size_t *pDataSize, void *pData);
using PFN_vkGetPrivateData = void (*)(Device device, ObjectType objectType, uint64_t objectHandle, PrivateDataSlot privateDataSlot, uint64_t *pData);
using PFN_vkGetQueryPoolResults = Result (*)(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, DeviceSize stride, QueryResultFlags flags);
using PFN_vkGetRenderAreaGranularity = void (*)(Device device, RenderPass renderPass, Extent2D *pGranularity);
using PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = Result (*)(Device device, const SamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData);
using PFN_vkGetSemaphoreCounterValue = Result (*)(Device device, Semaphore semaphore, uint64_t *pValue);
using PFN_vkGetSwapchainImagesKHR = Result (*)(Device device, SwapchainKHR swapchain, uint32_t *pSwapchainImageCount, Image *pSwapchainImages);
using PFN_vkInvalidateMappedMemoryRanges = Result (*)(Device device, uint32_t memoryRangeCount, const MappedMemoryRange *pMemoryRanges);
using PFN_vkMapMemory = Result (*)(Device device, DeviceMemory memory, DeviceSize offset, DeviceSize size, MemoryMapFlags flags, void ** ppData);
using PFN_vkMergePipelineCaches = Result (*)(Device device, PipelineCache dstCache, uint32_t srcCacheCount, const PipelineCache *pSrcCaches);
using PFN_vkQueueBeginDebugUtilsLabelEXT = void (*)(Queue queue, const DebugUtilsLabelEXT *pLabelInfo);
using PFN_vkQueueBindSparse = Result (*)(Queue queue, uint32_t bindInfoCount, const BindSparseInfo *pBindInfo, Fence fence);
using PFN_vkQueueEndDebugUtilsLabelEXT = void (*)(Queue queue);
using PFN_vkQueueInsertDebugUtilsLabelEXT = void (*)(Queue queue, const DebugUtilsLabelEXT *pLabelInfo);
using PFN_vkQueuePresentKHR = Result (*)(Queue queue, const PresentInfoKHR *pPresentInfo);
using PFN_vkQueueSubmit = Result (*)(Queue queue, uint32_t submitCount, const SubmitInfo *pSubmits, Fence fence);
using PFN_vkQueueSubmit2 = Result (*)(Queue queue, uint32_t submitCount, const SubmitInfo2 *pSubmits, Fence fence);
using PFN_vkQueueWaitIdle = Result (*)(Queue queue);
using PFN_vkResetCommandBuffer = Result (*)(CommandBuffer commandBuffer, CommandBufferResetFlags flags);
using PFN_vkResetCommandPool = Result (*)(Device device, CommandPool commandPool, CommandPoolResetFlags flags);
using PFN_vkResetDescriptorPool = Result (*)(Device device, DescriptorPool descriptorPool, DescriptorPoolResetFlags flags);
using PFN_vkResetEvent = Result (*)(Device device, Event event);
using PFN_vkResetFences = Result (*)(Device device, uint32_t fenceCount, const Fence *pFences);
using PFN_vkResetQueryPool = void (*)(Device device, QueryPool queryPool, uint32_t firstQuery, uint32_t queryCount);
using PFN_vkSetDebugUtilsObjectNameEXT = Result (*)(Device device, const DebugUtilsObjectNameInfoEXT *pNameInfo);
using PFN_vkSetDebugUtilsObjectTagEXT = Result (*)(Device device, const DebugUtilsObjectTagInfoEXT *pTagInfo);
using PFN_vkSetEvent = Result (*)(Device device, Event event);
using PFN_vkSetPrivateData = Result (*)(Device device, ObjectType objectType, uint64_t objectHandle, PrivateDataSlot privateDataSlot, uint64_t data);
using PFN_vkSignalSemaphore = Result (*)(Device device, const SemaphoreSignalInfo *pSignalInfo);
using PFN_vkSubmitDebugUtilsMessageEXT = void (*)(Instance instance, DebugUtilsMessageSeverityFlagsEXT messageSeverity, DebugUtilsMessageTypeFlagsEXT messageTypes, const DebugUtilsMessengerCallbackDataEXT *pCallbackData);
using PFN_vkTrimCommandPool = void (*)(Device device, CommandPool commandPool, CommandPoolTrimFlags flags);
using PFN_vkUnmapMemory = void (*)(Device device, DeviceMemory memory);
using PFN_vkUpdateDescriptorSetWithTemplate = void (*)(Device device, DescriptorSet descriptorSet, DescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData);
using PFN_vkUpdateDescriptorSets = void (*)(Device device, uint32_t descriptorWriteCount, const WriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const CopyDescriptorSet *pDescriptorCopies);
using PFN_vkWaitForFences = Result (*)(Device device, uint32_t fenceCount, const Fence *pFences, Bool waitAll, uint64_t timeout);
using PFN_vkWaitSemaphores = Result (*)(Device device, const SemaphoreWaitInfo *pWaitInfo, uint64_t timeout);

} // namespace vull::vkb
// NOLINTEND
