#version 450
#include "common.glsl"

layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout (std140, set = 0, binding = 0) buffer readonly Lights {
    uint g_light_count;
    PointLight g_lights[];
};
layout (set = 0, binding = 1) buffer writeonly LightVisibilities {
    LightVisibility g_light_visibilities[];
};
layout (set = 1, binding = 0) uniform UniformBuffer {
    mat4 proj;
    mat4 view;
    mat4 transform;
    vec3 camera_position;
} g_ubo;
layout (set = 2, binding = 0) uniform sampler2D g_depth_sampler;
layout (push_constant) uniform PushConstantObject {
    ivec2 tile_nums;
    ivec2 viewport_size;
} g_push_constants;

struct ViewFrustum {
    vec3 planes[4];
    float min_depth;
    float max_depth;
};

shared uint g_min_depth_int;
shared uint g_max_depth_int;
shared uint g_tile_light_count;
shared ViewFrustum g_frustum;

vec4 proj_to_view(mat4 inv_proj, vec4 p) {
    p = inv_proj * p;
    p /= p.w;
    return p;
}

ViewFrustum create_frustum() {
    uint rast_xt = gl_WorkGroupID.x * TILE_SIZE;
    uint rast_yt = gl_WorkGroupID.y * TILE_SIZE;
    uint rast_xb = (gl_WorkGroupID.x + 1) * TILE_SIZE;
    uint rast_yb = (gl_WorkGroupID.y + 1) * TILE_SIZE;

    vec4 top_left = vec4(
        float(rast_xt) / float(g_push_constants.viewport_size.x) * 2.f - 1.f,
        float(rast_yt) / float(g_push_constants.viewport_size.y) * 2.f - 1.f,
        1.f,
        1.f
    );
    vec4 bottom_left = vec4(
        top_left.x,
        float(rast_yb) / float(g_push_constants.viewport_size.y) * 2.f - 1.f,
        1.f,
        1.f
    );
    vec4 bottom_right = vec4(
        float(rast_xb) / float(g_push_constants.viewport_size.x) * 2.f - 1.f,
        bottom_left.y,
        1.f,
        1.f
    );
    vec4 top_right = vec4(
        bottom_right.x,
        top_left.y,
        1.f,
        1.f
    );

    mat4 inv_proj = inverse(g_ubo.proj);
    vec3 top_left_vs = proj_to_view(inv_proj, top_left).xyz;
    vec3 bottom_left_vs = proj_to_view(inv_proj, bottom_left).xyz;
    vec3 bottom_right_vs = proj_to_view(inv_proj, bottom_right).xyz;
    vec3 top_right_vs = proj_to_view(inv_proj, top_right).xyz;

    ViewFrustum frustum;
    frustum.planes[0] = normalize(cross(top_right_vs, top_left_vs));
    frustum.planes[1] = normalize(cross(top_left_vs, bottom_left_vs));
    frustum.planes[2] = normalize(cross(bottom_left_vs, bottom_right_vs));
    frustum.planes[3] = normalize(cross(bottom_right_vs, top_right_vs));
    frustum.min_depth = uintBitsToFloat(g_min_depth_int);
    frustum.max_depth = uintBitsToFloat(g_max_depth_int);
    return frustum;
}

bool has_collided(PointLight light, ViewFrustum frustum) {
    for (int i = 0; i < 4; i++) {
        if (dot(light.position, frustum.planes[i]) < -light.radius) {
            return false;
        }
    }
    if (frustum.max_depth - light.position.z >= light.radius) {
        return false;
    }
    if (light.position.z - frustum.min_depth >= light.radius) {
        return false;
    }
    return true;
}

void main() {
    ivec2 tile_id = ivec2(gl_WorkGroupID.xy);
    uint tile_index = tile_id.y * gl_NumWorkGroups.x + tile_id.x;
    if (gl_LocalInvocationIndex == 0) {
        g_min_depth_int = 0xFFFFFFFF;
        g_max_depth_int = 0;
        g_tile_light_count = 0;
    }
    barrier();
    float depth = texture(g_depth_sampler, gl_GlobalInvocationID.xy).r;
    uint depth_int = floatBitsToUint(depth);
    atomicMin(g_min_depth_int, depth_int);
    atomicMax(g_min_depth_int, depth_int);
    barrier();
    if (gl_LocalInvocationIndex == 0) {
        g_frustum = create_frustum();
    }
    barrier();
    for (uint i = gl_LocalInvocationIndex; i < g_light_count; i += TILE_SIZE * TILE_SIZE) {
        if (!has_collided(g_lights[i], g_frustum)) {
            continue;
        }
        uint slot = atomicAdd(g_tile_light_count, 1);
        if (slot >= MAX_LIGHTS_PER_TILE) {
            break;
        }
        g_light_visibilities[tile_index].indices[slot] = i;
    }
    barrier();
    if (gl_LocalInvocationIndex == 0) {
        g_light_visibilities[tile_index].count = min(MAX_LIGHTS_PER_TILE, g_tile_light_count);
    }
}
